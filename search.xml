<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis配置</title>
      <link href="/2020/09/01/redis-config/"/>
      <url>/2020/09/01/redis-config/</url>
      
        <content type="html"><![CDATA[<h4 id="启动设置"><a href="#启动设置" class="headerlink" title="启动设置"></a>启动设置</h4><p>将redis下的文件redis.conf备份一份，修改时直接修改原本的配置文件，将Redis改为后台启动(默认启动的方式不是后台启动)</p><p>将Redis.conf中daemonize由no改为yes</p><pre class=" language-shell"><code class="language-shell">################################# GENERAL ###################################### By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.#daemonize nodaemonize yes</code></pre><p>然后用修改过的配置文件启动，</p><pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ src]# ./redis-server ../redis.conf 5643:C 06 Sep 2020 23:42:14.977 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo5643:C 06 Sep 2020 23:42:14.977 # Redis version=6.0.7, bits=64, commit=00000000, modified=0, pid=5643, just started5643:C 06 Sep 2020 23:42:14.977 # Configuration loaded</code></pre><h4 id="RDB配置"><a href="#RDB配置" class="headerlink" title="RDB配置"></a>RDB配置</h4><p>RDB的相关配置很多，主要配置的是触发规则</p><pre class=" language-shell"><code class="language-shell">#   save ""save 900 1save 300 10save 60 10000# 第一个数是时间，第二个是修改次数#比如save 60 10000就是60秒内修改了10000次触发</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>database/sql包</title>
      <link href="/2020/08/20/databaseSql/"/>
      <url>/2020/08/20/databaseSql/</url>
      
        <content type="html"><![CDATA[<p>database/sql包是go语言官方提供的sql连接和使用的包，用以操作SQL和类SQL数据库，但是官方没有提供驱动，需要自己手动安装</p><h4 id="安装mysql驱动包"><a href="#安装mysql驱动包" class="headerlink" title="安装mysql驱动包"></a>安装mysql驱动包</h4><p>在终端输入以下命令,就能安装mysql的驱动包</p><pre class=" language-shell"><code class="language-shell">E:\code\go\src\design&gt;go get github.com/go-sql-driver/mysqlgo: github.com/go-sql-driver/mysql upgrade =&gt; v1.5.0</code></pre><h4 id="导入相关包"><a href="#导入相关包" class="headerlink" title="导入相关包"></a>导入相关包</h4><p>在代码中导入database/sql包和驱动包,驱动包需要使用下划线导包的方式</p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"database/sql"</span>    <span class="token boolean">_</span> <span class="token string">"github.com/go-sql-driver/mysql"</span><span class="token punctuation">)</span></code></pre><h4 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h4><p>sql.Open()函数可以连接数据库，第一个参数是驱动名称，第二个参数是连接数据库必须要用到信息,DB不是连接，只有当需要使用时才会创建连接，如果想立即验证连接，需要用Ping()方法</p><pre class=" language-go"><code class="language-go">db<span class="token punctuation">,</span>err<span class="token operator">:=</span>sql<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"mysql"</span><span class="token punctuation">,</span><span class="token string">"user:password@tcp(127.0.0.1:3306)/database"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//fmt.Println("连接失败")</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> db<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    err <span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"状态错误"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><p>使用数据库查询语言时，先用rows对象(sql.go中定义的结构体)接收db.Query()查询的结果，然后使用rows对象的next方法进行迭代,rows使用完也需要使用close方法关闭资源，把遍历到的数据存入变量使用rows.Scan()</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> sql <span class="token builtin">string</span><span class="token operator">=</span><span class="token string">"select user_id,user_name from user;"</span>    <span class="token keyword">var</span><span class="token punctuation">(</span>        id <span class="token builtin">string</span>        name <span class="token builtin">string</span>    <span class="token punctuation">)</span>    rows<span class="token punctuation">,</span>err<span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"查询失败"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> rows<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> rows<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">:=</span>rows<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>id<span class="token punctuation">,</span><span class="token operator">&amp;</span>name<span class="token punctuation">)</span>        <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"查询失败"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s-----%s\n"</span><span class="token punctuation">,</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><p>在使用数据库操作语言的时候，使用db.Exec()方法可以执行insert、update、delete等语句</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> sqlStr<span class="token operator">=</span><span class="token string">"update user set user_name=? where user_id=?"</span>     result<span class="token punctuation">,</span>err<span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sqlStr<span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span>         fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"跟新失败"</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>     rows<span class="token punctuation">,</span>err<span class="token operator">:=</span>result<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>     fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>rows<span class="token punctuation">)</span></code></pre><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p>使用数据库定义语言的时候，同样是通过db.Exec()方法</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> sqlStr<span class="token operator">=</span><span class="token string">"create table test(id int not null,info varchar(100) not null)"</span>    res<span class="token punctuation">,</span>err<span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"err"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><p>数据库控制语言现阶段用得少，后面再补充</p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><h5 id="普通SQL语句的执行："><a href="#普通SQL语句的执行：" class="headerlink" title="普通SQL语句的执行："></a>普通SQL语句的执行：</h5><ol><li>客户端对SQL语句进行占位符替换的到完整的SQL语句</li><li>将完整的SQL语句发送到mysql服务端</li><li>mysql服务端执行SQL语句并返回结果</li></ol><h5 id="预处理的sql："><a href="#预处理的sql：" class="headerlink" title="预处理的sql："></a>预处理的sql：</h5><ol><li>将SQL语句分为命令部分和数据部分</li><li>先把命令部分发送给mysql服务端，mysql服务端进行SQL预处理</li><li>然后把数据部分发送给mysql服务端进行占位符替换</li><li>mysql执行完整的SQL语句并返回结果</li></ol><h5 id="预处理的好处："><a href="#预处理的好处：" class="headerlink" title="预处理的好处："></a>预处理的好处：</h5><ol><li>优化mysql重复执行sql的方法，可以提升服务器性能，提前编译之后，可以多次执行</li><li>可以避免SQL注入</li></ol><pre class=" language-go"><code class="language-go">        <span class="token keyword">var</span> sqlStr<span class="token operator">=</span><span class="token string">"select user_name from user where user_id&lt;3"</span>    statement<span class="token punctuation">,</span>err <span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Prepare</span><span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">defer</span> statement<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    rows<span class="token punctuation">,</span>err<span class="token operator">:=</span>statement<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> name <span class="token builtin">string</span>    <span class="token keyword">for</span> rows<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        err<span class="token operator">:=</span>rows<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>name<span class="token punctuation">)</span>        <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    rows<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>DML操作</p><pre class=" language-go"><code class="language-go">    <span class="token keyword">var</span> sqlStr<span class="token operator">=</span><span class="token string">"delete from user where user_id=?"</span>    statement<span class="token punctuation">,</span>err <span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Prepare</span><span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">defer</span> statement<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    res<span class="token punctuation">,</span>err<span class="token operator">:=</span>statement<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    rowNum<span class="token punctuation">,</span>err <span class="token operator">:=</span>res<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"改变了%d行"</span><span class="token punctuation">,</span>rowNum<span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> go语言 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言包管理</title>
      <link href="/2020/08/20/goPackage/"/>
      <url>/2020/08/20/goPackage/</url>
      
        <content type="html"><![CDATA[<p>前言：在go语言中，有两种包管理方式gopath和go mod，导入自定义包和第三方包都需要准守一定的规则，并不是定义了包就能直接导入的。</p><h4 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h4><p>go语言安装第三方包的时候，直接用go get命令大部分时候会因为墙的问题无法安装成功，使用go mod包管理模式可以通过代理解决这个问题，设置代理是需要在终端执行以下命令</p><pre class=" language-shell"><code class="language-shell">go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct</code></pre><p>在go mod模式下，想要导入自定义包，需要创建go.mod文件，这样才可以成功导入并且使用自定义包</p><pre class=" language-shell"><code class="language-shell">go mod init</code></pre><p>go mod不依赖gopath，使用比较方便，还有以下一种常见命令<br><img src="../img/gomod.jpg" alt=""> </p><h4 id="gopath模式"><a href="#gopath模式" class="headerlink" title="gopath模式"></a>gopath模式</h4><p>gopath包管理方式是默认的管理方式，gopath包管理模式要求工程项目必须放在gopath下的src目录下，想要导入自定义包，需要先编译包，然后再安装包</p><pre class=" language-shell"><code class="language-shell">go build packagego install package</code></pre><h4 id="下划线导包"><a href="#下划线导包" class="headerlink" title="下划线导包"></a>下划线导包</h4><p>在go语言中，可以在包名前面加上下划线,这种做法只执行该库的 init 函数而不对其它导出对象进行真正地导入</p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"database/sql"</span>    <span class="token boolean">_</span><span class="token string">"github.com/go-sql-driver/mysql"</span><span class="token punctuation">)</span></code></pre><h4 id="点号导包"><a href="#点号导包" class="headerlink" title="点号导包"></a>点号导包</h4><p>这样的导包方式可以省略包名直接使用函数等</p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"github.com/lxn/walk"</span>    <span class="token punctuation">.</span> <span class="token string">"github.com/lxn/walk/declarative"</span>    <span class="token string">"strings"</span><span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2020/08/19/DesignPattern/"/>
      <url>/2020/08/19/DesignPattern/</url>
      
        <content type="html"><![CDATA[<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>所谓单例，就是整个程序有且仅有一个实例，go语言实现单例模式有懒汉式、饿汉式、双重检查、sync.Once这几种方法</p><h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><p>在需要用到时才创建实例，但不是线程安全的，在多线程（协程）模式时可以被创建多个实例</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name <span class="token builtin">string</span>    Age <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">var</span> p <span class="token operator">*</span>person<span class="token keyword">func</span> <span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>person<span class="token punctuation">{</span>    <span class="token keyword">if</span> p<span class="token operator">==</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        p<span class="token operator">=</span><span class="token function">new</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>        p<span class="token punctuation">.</span>Name<span class="token operator">=</span><span class="token string">"hello"</span>        p<span class="token punctuation">.</span>Age<span class="token operator">=</span><span class="token number">12</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    p<span class="token operator">:=</span> <span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>    f<span class="token operator">:=</span><span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    f<span class="token punctuation">.</span>Name<span class="token operator">=</span><span class="token string">"zhangsan"</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出结果</span>hellozhangsan</code></pre><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p>实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说，占用内存</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name <span class="token builtin">string</span>    Age <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">var</span> p <span class="token operator">*</span>person<span class="token operator">=</span><span class="token operator">&amp;</span>person<span class="token punctuation">{</span>Name<span class="token punctuation">:</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span>Age<span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>person<span class="token punctuation">{</span>    <span class="token keyword">return</span> p<span class="token punctuation">}</span></code></pre><h5 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h5><p>在懒汉式的基础上再进行优化，减少加锁的操作，保证线程安全的同时不影响性能。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name <span class="token builtin">string</span>    Age <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">var</span> lock sync<span class="token punctuation">.</span>Mutex<span class="token keyword">var</span> p <span class="token operator">*</span>person<span class="token keyword">func</span> <span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>person<span class="token punctuation">{</span>    <span class="token keyword">if</span> p<span class="token operator">==</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> p<span class="token operator">==</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>            p<span class="token operator">=</span><span class="token function">new</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">}</span></code></pre><h5 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h5><p>sync.Once可以确保只执行一次，本质上还是双重检查</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name <span class="token builtin">string</span>    Age <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">var</span> p <span class="token operator">*</span>person<span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>person<span class="token punctuation">{</span>    once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token operator">=</span><span class="token function">new</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>        p<span class="token punctuation">.</span>Name<span class="token operator">=</span><span class="token string">"hello"</span>        p<span class="token punctuation">.</span>Age<span class="token operator">=</span><span class="token number">12</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> p<span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> go语言 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker笔记</title>
      <link href="/2020/08/15/dockerNote/"/>
      <url>/2020/08/15/dockerNote/</url>
      
        <content type="html"><![CDATA[<h4 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h4><p>是一个开源的应用容器引擎，解决了部署环境配置麻烦的问题，可以让部署变得简单高效。</p><h4 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h4><p>有效的将单个操作系统的资源划分到孤立的组中，以便更好的在孤立的组之间平衡有冲突的资源使用需求，这种技术就是容器技术。</p><p>容器话技术不是模拟的一个完整的操作系统，容器内的应用直接运行在宿主机的内核之上，没有自己的内核</p><h4 id="DevOps（开发、运维）"><a href="#DevOps（开发、运维）" class="headerlink" title="DevOps（开发、运维）"></a>DevOps（开发、运维）</h4><h5 id="应用更快速地开发和部署"><a href="#应用更快速地开发和部署" class="headerlink" title="应用更快速地开发和部署"></a>应用更快速地开发和部署</h5><ul><li>传统：帮助文档众多</li><li>docker:打包镜像发布测试，一键运行</li></ul><h5 id="更便捷地升级和扩容"><a href="#更便捷地升级和扩容" class="headerlink" title="更便捷地升级和扩容"></a>更便捷地升级和扩容</h5><p>使用docker后，部署应用就和搭积木一样</p><h5 id="更简单的系统运维"><a href="#更简单的系统运维" class="headerlink" title="更简单的系统运维"></a>更简单的系统运维</h5><p>使用容器之后，开发、测试环境保持高度一致</p><h5 id="更高效的计算机资源利用"><a href="#更高效的计算机资源利用" class="headerlink" title="更高效的计算机资源利用"></a>更高效的计算机资源利用</h5><p>docker是内核级别的虚拟化，可以在一个物理机上运行很多个容器实例</p><h4 id="docker组件"><a href="#docker组件" class="headerlink" title="docker组件"></a>docker组件</h4><h5 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h5><h5 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h5><h5 id="仓库（repository）"><a href="#仓库（repository）" class="headerlink" title="仓库（repository）"></a>仓库（repository）</h5><h4 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h4><p>1.安装yum-utils软件包（提供yum-config-manager 实用程序）并设置稳定的存储库。</p><pre class=" language-shell"><code class="language-shell">sudo yum install -y yum-utilssudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p>2.安装DOCKER引擎</p><pre class=" language-shell"><code class="language-shell">sudo yum install docker-ce docker-ce-cli containerd.io</code></pre><p>3.启动docker</p><pre class=" language-shell"><code class="language-shell">sudo systemctl start docker</code></pre><p>4.运行hello-world 映像来验证是否正确安装了Docker Engine</p><pre class=" language-shell"><code class="language-shell">sudo docker run hello-world</code></pre><h4 id="docker底层原理"><a href="#docker底层原理" class="headerlink" title="docker底层原理"></a>docker底层原理</h4><p>工作原理：docker是一个c/s架构的系统，docker的守护进程运行在主机上，通过socket从客户端访问，dockerServer收到这个命令，就会去执行</p><h4 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h4><h5 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h5><ul><li>docker version：查看docker版本信息</li><li>docker info:查看docker的系统信息</li><li>docker 命令 –help:查看某命令的用法</li></ul><h5 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h5><ul><li>docker images<pre class=" language-shell"><code class="language-shell">[root@izbp1hrzkalf9rl3l0lzehz ~]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              bf756fb1ae65        7 months ago        13.3kB</code></pre></li></ul><p>REPOSITORY             #镜像的仓库源<br>TAG                    #镜像的标签<br>IMAGE ID               #镜像的ID<br>CREATED                #镜像的创建时间<br>SIZE                   #镜像的大小</p><p>命令可选项<br>-a, –all             #列出所有镜像<br>-q, –quit            #列出镜像的ID</p><pre><code>##### 镜像搜索命令- docker search：搜索镜像```shell script[root@izbp1hrzkalf9rl3l0lzehz ~]# docker search redisNAME                             DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDredis                            Redis is an open source key-value store that…   8484                [OK]                bitnami/redis                    Bitnami Redis Docker Image                      158                                     [OK]sameersbn/redis                                                                  80                                      [OK]grokzen/redis-cluster            Redis cluster 3.0, 3.2, 4.0, 5.0, 6.0           70                                      rediscommander/redis-commander   Alpine image for redis-commander - Redis man…   46                                      [OK]</code></pre><h5 id="下载命令"><a href="#下载命令" class="headerlink" title="下载命令"></a>下载命令</h5><ul><li>docker pull:<pre class=" language-shell"><code class="language-shell">[root@izbp1hrzkalf9rl3l0lzehz ~]# docker pull redisUsing default tag: latestlatest: Pulling from library/redisbf5952930446: Pull complete 911b8422b695: Pull complete 093b947e0ade: Pull complete 5b1d5f59e382: Pull complete 7a5f59580c0b: Pull complete f9c63997c980: Pull complete Digest: sha256:09c33840ec47815dc0351f1eca3befe741d7105b3e95bc8fdb9a7e4985b9e1e5Status: Downloaded newer image for redis:latestdocker.io/library/redis:latests</code></pre></li></ul><h5 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h5><ul><li>sudo systemctl restart docker</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言</title>
      <link href="/2020/08/14/go-web/"/>
      <url>/2020/08/14/go-web/</url>
      
        <content type="html"><![CDATA[<h4 id="简易服务"><a href="#简易服务" class="headerlink" title="简易服务"></a>简易服务</h4><p>net/http包是go语言自带的一个包，使用这个包可以极为方便地搭建一个web后台,也可以使用这个包来发送各种请求，编写爬虫。</p><p>后台想要接收和识别浏览器发过来的http请求，需要实现一个函数，这个函数的参数为(w http.ResponseWriter,r *http.Request)，形参名可变</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>handler<span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:8000"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">handler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span>r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>处理http请求的时候，也可以使用http.Handle()函数，使用该函数需要自己先实现一个Handle接口,该接口仅有一个ServeHTTP(ResponseWriter, *Request)方法，所以定义一个字段个数为0的结构体，实现该方法即可</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span><span class="token function">new</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//http.HandleFunc("/",handler)</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:8000"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> handle <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span><span class="token punctuation">(</span>h <span class="token operator">*</span>handle<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span>r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token string">"hello world!->handel"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>go语言自带的有text/template和html/template两个包，都可以解析HTML文档，两个模板引擎用法相似</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"html/template"</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>handler<span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:8001"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">handler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span>r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span>    t<span class="token punctuation">,</span>err<span class="token operator">:=</span>template<span class="token punctuation">.</span><span class="token function">ParseFiles</span><span class="token punctuation">(</span><span class="token string">"main/404.html"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    t<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>处理静态资源时，使用http.StripPrefix()函数，会自动匹配某一前缀的请求，并将其替换成第二个参数(handle类型)中的物理路径</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"html/template"</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/static/"</span><span class="token punctuation">,</span>http<span class="token punctuation">.</span><span class="token function">StripPrefix</span><span class="token punctuation">(</span><span class="token string">"/static/"</span><span class="token punctuation">,</span>http<span class="token punctuation">.</span><span class="token function">FileServer</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">Dir</span><span class="token punctuation">(</span><span class="token string">"static/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>handler<span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:8001"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">handler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span>r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span>    t<span class="token punctuation">,</span>err<span class="token operator">:=</span>template<span class="token punctuation">.</span><span class="token function">ParseFiles</span><span class="token punctuation">(</span><span class="token string">"main/404.html"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    t<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> go语言 </tag>
            
            <tag> net/http包 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis笔记</title>
      <link href="/2020/08/10/redisNote/"/>
      <url>/2020/08/10/redisNote/</url>
      
        <content type="html"><![CDATA[<h4 id="NoSQL概念"><a href="#NoSQL概念" class="headerlink" title="NoSQL概念"></a>NoSQL概念</h4><ul><li>NoSQL：not only SQL，泛指非关系型数据库</li><li>常见分类：键值对存储数据库、列存储数据库、文档存储数据库、图形数据库</li><li>优点：1.方便扩展（数据之间没有关系，好扩展） 2.大数据量高性能 3.数据类型多样（不需要设计数据库）</li><li>大数据时代3V和3高：海量（Volume）、多样（Variety）、实时（Velocity），高并发、高可用、高可扩</li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。Redis是单线程的。</p><h4 id="Redis操作"><a href="#Redis操作" class="headerlink" title="Redis操作"></a>Redis操作</h4><p>常见命令</p><h5 id="清空（慎用）"><a href="#清空（慎用）" class="headerlink" title="清空（慎用）"></a>清空（慎用）</h5><ul><li>flushdb：  清空当前数据库</li><li>flushall:  清空全部数据库</li></ul><h5 id="Redis-key类型"><a href="#Redis-key类型" class="headerlink" title="Redis-key类型"></a>Redis-key类型</h5><ul><li>select db：选择数据库</li><li>keys *：查看所有的key（数据量小时使用，数据量大了会大量占用内存，导致机器瘫痪）</li><li>info、info Keyspace：查看</li><li>set key value:设置键值对,如果键存在就是修改，不存在就是添加</li><li>exists key:查看是否存在key</li><li>move key db：将键值对移动到另一个数据库中去</li><li>get key：获取key</li><li>mset k1 v1 k2 v2…：同时设置多个键值对</li><li>mget k1 k2 …：同时获取多个值</li><li>setex key time value：为指定的 key 设置值及其过期时间</li><li>del key：删除键值对</li><li>expire key time:设置过期时间</li><li>ttl key：查看还有多久过期</li><li>type key：查看类型</li></ul><h5 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h5><ul><li>incr key:key对应的整数值加1</li><li>incrby key num:key对应的整数值增加num</li><li>decr key：key对应的整数值减1</li><li>decrby key num:key对应的整数值增减num</li><li>getrange key start end:从start到end范围截取key对应的字符串值，是一个闭区间<pre class=" language-sql"><code class="language-sql">获取全部内容getrange <span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span></code></pre></li><li>setrange key start end value:将start到end区间替换为value</li><li>setnx key value:在指定的 key 不存在时，为 key 设置指定的值,如果存在就会设置失败</li><li>msetnx k1 v1 k2 v2…:批量设置，要么一起成功，要么一起失败</li></ul><pre class=" language-sql"><code class="language-sql">设置<span class="token keyword">user</span>:<span class="token number">1</span>对象<span class="token punctuation">,</span>用json方式<span class="token keyword">set</span> <span class="token keyword">user</span>:<span class="token number">1</span>{name:xx<span class="token punctuation">,</span>age:<span class="token number">1</span>}<span class="token keyword">key</span>的设计:<span class="token keyword">user</span>:{id}:{filed}mset <span class="token keyword">user</span>:<span class="token number">1</span> name xx <span class="token keyword">user</span>:<span class="token number">1</span> age <span class="token number">1</span></code></pre><h5 id="list：可作为栈、队列、阻塞队列使用"><a href="#list：可作为栈、队列、阻塞队列使用" class="headerlink" title="list：可作为栈、队列、阻塞队列使用"></a>list：可作为栈、队列、阻塞队列使用</h5><ul><li>lpush list value:在list左边添加</li><li>rpush list value:在list右边添加</li><li>lpop list:弹出最左边元素</li><li>rpop list:弹出最右边元素</li><li>lrange list start end:截取start到end的元素</li><li>lindex list index:通过下标获取值</li><li>llen list：获取list的大小</li><li>lpoprpush list1 list2:组合命令，将list1中的最左元素添加到list2的最右边</li><li>lset list index value:将第index个元素替换成value</li></ul><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><ul><li>sadd set value:在set中添加一个元素</li><li>scard set:获取set中元素的个数</li><li>sdiff set1 set2：返回集合之间的差集</li><li>sinter set1 set2:返回集合之间的交集</li><li>sunion set1 set2:返回集合之间的并集</li><li>smembers set:返回set中的所有成员</li><li>spop set:随机删除并返回一个元素</li><li>sismember set value:判断value是否是set中的元素</li><li>smove set1 set2 value：将一个指定的set1中的值移动大另一个set2中</li></ul><h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><ul><li>hset hash field value:给hash设置字段</li><li>hget hash field:获取字段</li><li>hmset hash field1 value1 [……]:批量获取字段</li><li>hgetall hash:获取全部数据</li><li>hdel hash field：删除hash中的字段</li><li>hlen hash:获取hash字段数量</li><li>hexists hash filed：查看字段是否存在</li><li>hkeys hash:获取所有key</li><li>hvals hash:获取所有值</li><li>hincrby hash field number:field增加number</li><li>hsetnx hash field value:如果field不存在，则可以设值</li></ul><h5 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset(有序集合)"></a>zset(有序集合)</h5><ul><li>zset key1 score value:</li><li>zadd set key value:添加元素</li><li>zrange set start end:从start到end截取set元素</li><li>zrangebyscore set -inf +inf:从小到大排序</li><li>zrem set field:删除元素</li><li>zcard set：获取有序集合中的个数</li><li>zcount set start end:获取start到end之间的元素个数</li></ul><h5 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial 地理位置"></a>geospatial 地理位置</h5><p>应用：定位信息存储、附近的人计算、打车距离计算,底层维护的是一个zset，可以是有zset的操作</p><ul><li><p>geoadd key  longitude latitude member:用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</p><pre class=" language-sql"><code class="language-sql">geoadd china:city <span class="token number">116.40</span> <span class="token number">39.90</span> beijing</code></pre></li><li><p>geodist key member1 member2 [m米/km千米/ft英尺/mi英里]:按照给定的单位返回两个定位之间的距离</p><pre class=" language-sql"><code class="language-sql">geodist china:city beijing shanghai km </code></pre></li><li><p>georadius key longtitude latitude radius m/km/ft/mi:以给定的经纬度为中心，找出某一半径内的元素</p><pre class=" language-sql"><code class="language-sql">georadius china:city <span class="token number">110</span> <span class="token number">30</span> <span class="token number">1000</span> km</code></pre></li><li><p>geopos key member:获取member的经纬度</p><pre class=" language-sql"><code class="language-sql">geopos china:city beijing</code></pre></li><li><p>zrem key member：移除member</p></li><li><p>zrange key start end：截取从start到end的元素</p></li></ul><h5 id="hyperloglog"><a href="#hyperloglog" class="headerlink" title="hyperloglog"></a>hyperloglog</h5><p>用于基数统计相关，基数是指多个数据集中不重复的元素，hyperloglog存在一定的误差,但是占用的内存是固定的64k<br>网站访问人数统计等可以用次结构来做</p><ul><li>pfadd key element:添加元素</li><li>pfcount key:返回元素个数</li><li>pfmerge key1 ke2 k3:将k2和k3合并为key1</li></ul><h5 id="bitmap：位图"><a href="#bitmap：位图" class="headerlink" title="bitmap：位图"></a>bitmap：位图</h5><ul><li>setbit key offset value：把key的offset位设为value,value取值为0或1</li><li>getbit key offset:获取第offset位的值</li><li>bitcount key [start end]：获取从start到end范围内的1的个数</li></ul><h4 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h4><p>Redis的事务跟mysql登封关系型数据库是不同的，Redis单条命令是原子性的，要么成功要么失败，而Redis的事务不保证原子性。</p><p>Redis事务的本质就是一组命令的集合，将所有命令放入队列暂不执行，输入事务执行命令后才会开始执行，然后依次执行</p><p>Redis事务的顺序：</p><ol><li>开启事务</li><li>命令入队</li><li>执行事务</li></ol><pre class=" language-sql"><code class="language-sql">开启事务<span class="token operator">-</span><span class="token operator">></span>  multi   <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">set</span> k1 v1<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">set</span> k2 v2<span class="token operator">-</span><span class="token operator">></span>  get k1<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">set</span> k3 v3执行事务<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">exec</span>取消事务<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">discard</span></code></pre><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p><p>Redis的乐观锁实现采用的是watch命令</p><ul><li>watch key:监视key，如果key被改变则事务中断</li><li>unwatch key：取消监视</li></ul><p>如果事务失败，先解锁，然后重新加锁，再次进行事务操作</p><p><img src="../img/OptimisticLocking.png" alt=""></p><h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><h5 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h5><p>RDB：保存redis数据的快照，Redis会单独创建(fork)一个子进程来进行持久化,会先将数据写入到一个临时文件中(dump.rdb)，持久化进程结束后，再替换以前持久化的文件。恢复时，Redis会直接将快照读入内存。</p><p>优点:</p><ol><li>一般时候对性能影响较小</li><li>非常适合做冷备</li><li>数据恢复快</li></ol><p>缺点:</p><ol><li>如果数据量大时候，内存占用较高</li><li>可能会丢失数据</li></ol><ol><li>save触发方式：该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止<br><img src="../img/rdb.jpg" alt=""></li><li>bgsave触发方式：执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求<br><img src="../img/rdb2.jpg" alt=""></li><li>自动触发：在配置文件中设置触发规则。执行flushall或者退出Redis时，也会自动触发RDB</li></ol><p>只要将RDB文件放在Redis启动目录，Redis启动时会自动恢复</p><h5 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h5><p>以日志的形式来记录每个写操作，将所有的指令记录下来，只许追加文件不允许写，Redis启动之后会读取该文件(appendonly.aof)重新构建。</p><p>与RDB不同，AOF需要手动开启。</p><p>AOF机制的优点:</p><ol><li>每一次修改都同步，数据完整性更高</li><li>每秒同步一次，则可能会丢失1秒的数据</li><li>从不同步，效率最高</li></ol><p>AOF的缺点：</p><ol><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</li><li>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</li><li>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</li><li>AOF文件错误，则Redis无法启动</li></ol><h4 id="Redis基准测试"><a href="#Redis基准测试" class="headerlink" title="Redis基准测试"></a>Redis基准测试</h4><p>redis-benchmark [option] [option value]</p><pre class=" language-sql"><code class="language-sql">同时执行 <span class="token number">10000</span> 个请求来检测性能redis<span class="token operator">-</span>benchmark <span class="token operator">-</span>n <span class="token number">10000</span> <span class="token operator">-</span>q</code></pre><h4 id="Redis订阅发布"><a href="#Redis订阅发布" class="headerlink" title="Redis订阅发布"></a>Redis订阅发布</h4><p>Redis订阅发布是一种消息通信模式：发送者(pub)发送消息,订阅者(sub)接收消息，Redis可以订阅任意数量的频道</p><p>订阅一个频道后，Redis-server里维护了一个字典，这个字典的键就是一个个频道，字典的值是一个链表，链表中包含了所有订阅这个频道的客户端。</p><p>订阅消息发布：<br><img src="../img/Redispubsub.png" alt=""></p><p>操作命令：</p><ul><li>subscribe name:订阅一个频道</li><li>publish name value:发布消息到频道</li></ul><h4 id="Redis集群部署"><a href="#Redis集群部署" class="headerlink" title="Redis集群部署"></a>Redis集群部署</h4><p>Redis在默认的情况下，每台Redis服务器都是一个主节点。一般使用时最少是一主二从的结构。</p><p>主节点是用来进行写操作的，从节点是用来进行读操作的。</p><ul><li>slaveof host port：将本机配置为某Redis服务器的从节点（重启之后会自动变回主节点）。</li></ul><p>在主节点断开后，从节点依旧是连接在主节点，但是无法进行写操作。主节点重新连接，从节点可以获取主节点的写信息。</p><p>主从复制的原理：salve节点启动连接到master节点后，会发送sync同步命令。master节点收到命令后，启动后台存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕后，master将传送整个数据文件到slave，并完成一次完全同步</p><p>全量复制：salve接收到文件之后，将其存盘并加载进内存<br>增量复制：master继续将行接收到的命令依次传给slave完成同步</p><p>只要重新连接master，一次完全同步(全量复制)将自动执行</p><p>主从复制的作用：</p><ol><li>热备份</li><li>故障恢复</li><li>负载均衡</li><li>高可用(集群)基石</li></ol><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>服务器宕机之后，手动配置的话费时费力，哨兵(sentinel)模式会自动从从节点中选举出一台作为主节点，如果原主节点恢复了，将会成为一个从节点</p><p>哨兵是一个独立的进程，会独立运行，哨兵通过发送命令，等待Redis服务器响应，从而监控多个Redis实例。多个哨兵之间也会相互监控。<br>服务器宕机后，只被一个哨兵发现时，会被该哨兵主观认为是不可用的，称为主观下线。多个哨兵检测到主节点不可用并且达到一定数量，哨兵会进行一次投票，投票由一个哨兵发起，进行failover(故障转移)操作。切换成功后，会通过发布订阅模式，让各个哨兵把自己监控的从节点实现切换为主节点，这个过程称为客观下线。</p><h4 id="Redis缓存穿透"><a href="#Redis缓存穿透" class="headerlink" title="Redis缓存穿透"></a>Redis缓存穿透</h4><p>缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源</p><p>例子：用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透</p><p>解决方案：</p><ol><li>布隆过滤器：</li><li>缓存空对象：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；带来的问题：如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ol><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>概念：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p><p>解决方案：</p><ol><li>Redis高可用</li><li>流量降级</li><li>数据预热</li></ol><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>概念：指一个key非常热点，扛着很大的并发量，当key失效的瞬间，持续的大并发就会穿破缓存层，直接请求数据库，数据库压力暴增。</p><p>解决方案：</p><ol><li>设置热点永不过期</li><li>加互斥锁</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> NoSQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2020/07/23/redblacktree/"/>
      <url>/2020/07/23/redblacktree/</url>
      
        <content type="html"><![CDATA[<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>定义：红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ol><li>每个节点要么是黑色，要么是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。</li><li>每个红色结点的两个子结点一定都是黑色（红黑树不会出现相邻的红色节点）</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li></ol><p>红黑树是一种黑色完美平衡的二叉树（不是完美平衡的二叉树）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 查找 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2020/07/16/tree/"/>
      <url>/2020/07/16/tree/</url>
      
        <content type="html"><![CDATA[<h4 id="树的介绍"><a href="#树的介绍" class="headerlink" title="树的介绍"></a>树的介绍</h4><p>树是节点按分支关系组成的一种结构，具有插入和删除效率高的优点，但是查找效率较低，二叉树不是树的特例（即二叉树不是树）</p><h4 id="常见二叉树分类"><a href="#常见二叉树分类" class="headerlink" title="常见二叉树分类"></a>常见二叉树分类</h4><ul><li>普通二叉树</li><li>完全二叉树</li><li>满二叉树</li><li>线索二叉树</li><li>哈夫曼树</li><li>二叉排序树</li><li>平衡二叉树（AVL）</li><li>红黑树</li></ul><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉树的存储结构可以用顺序存储和链式存储来存储。二叉树的顺序存储结构由一组连续的存储单元依次从上到下，从左到右存储完全二叉树的结点元素。对于一般二叉树，应将其与完全二叉树对应，然后给每个结点从1到i编上号，依次存储在大小为i-1的数组中。这种方法只适用于完全二叉树，对非完全二叉树会浪费较多空间，最坏情况一个深度为k的二叉树只有k个结点，却需要长度为2的k次方减一长度的一位数组。事实上，二叉树一般使用链式存储结构，由二叉树的定义可知，二叉树的结点由一个数据元素和分别指向其左右孩子的指针构成，即二叉树的链表结点中包含3个域，这种结点结构的二叉树存储结构称之为二叉链表。</p><h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/BTree.jpg" alt=""></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>定义：若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><h5 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/CompleteBinaryTree.jpg" alt=""></p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>定义：一棵二叉树的结点要么是叶子结点，要么它有两个子结点（如果一个二叉树的层数为K，且结点总数是(2^k) -1，则它就是满二叉树。）</p><h5 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/FullBinaryTree.jpg" alt=""></p><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>定义：对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树</p><h5 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/ThreadedBinaryTree.jpg" alt=""></p><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树（Huffman Tree）是在叶子结点和权重确定的情况下，带权路径长度最小的二叉树，也被称为最优二叉树。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p> <img src="../img/HuffmanTree.jpg" alt=""><br> <img src="../img/HuffmanTree2.jpg" alt=""></p><h4 id="二叉排序树（二叉搜索树、二叉查找树）"><a href="#二叉排序树（二叉搜索树、二叉查找树）" class="headerlink" title="二叉排序树（二叉搜索树、二叉查找树）"></a>二叉排序树（二叉搜索树、二叉查找树）</h4><p>定义：根节点的值大于其左子树中任意一个节点的值，小于其右节点中任意一节点的值，这一规则适用于二叉查找树中的每一个节点。</p><h5 id="图示-4"><a href="#图示-4" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/BinarySortTree.jpg" alt=""></p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>定义:可以是空树。假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过</p><h5 id="图示-5"><a href="#图示-5" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/BalanceTree.jpg" alt=""></p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>定义：红黑树就是一种平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。除了符合二叉查找树的特性之外，还具体下列的特性：</p><ol><li><p>节点是红色或者黑色</p></li><li><p>根节点是黑色</p></li><li><p>每个叶子的节点都是黑色的空节点（NULL）</p></li><li><p>每个红色节点的两个子节点都是黑色的。</p></li><li><p>从任意节点到其每个叶子的所有路径都包含相同的黑色节点。</p></li></ol><h5 id="图示-6"><a href="#图示-6" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/RedBlackTree.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2020/07/15/sort/"/>
      <url>/2020/07/15/sort/</url>
      
        <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思想：将数组分为已排序和未排序两部分，每次从未排序部分选出最小的数放入已排序部分</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="../img/2059345-20200607164933854-1279339529.gif" alt=""></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>记上待排序部分的第一个数字的索引min</li><li>对待排序部分遍历，如果有比第nums[min]小的，将索引值赋min</li><li>将待排序部分首元素与nums[min]交换</li><li>重复3和4</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>cur <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> cur<span class="token operator">>=</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> min <span class="token builtin">int</span><span class="token operator">=</span>cur    <span class="token keyword">for</span> i <span class="token operator">:=</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span>  <span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">{</span>            min<span class="token operator">=</span>i        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span>    cur<span class="token operator">++</span>    <span class="token function">SelectSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>cur<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序</p><h4 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h4><p><img src="../img/7789414-fb94ab5405281f89.png" alt=""></p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li>选择一个基准值，为了方便选择待排序部分首元素,用l表示左指针，r表示右指针</li><li>遍历待排序部分，对右指针向前移动，直到有小于基准值的元素出现，将r所指的值赋予l所指的元素,l小于r</li><li>对左指针进行移动，直到有大于基准值的元素出现，l所指的值赋予r所指的元素,l小于r</li><li>当l和r相等时，就将基准值赋予该元素，基准值将数组分为左右两部分，对这两部分进行2到4的操作</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>l <span class="token builtin">int</span><span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//对左右下标进行比较，l小于r时就返回，防止程序出错</span>    <span class="token keyword">if</span> l<span class="token operator">></span>r<span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//pviot为基准值</span>    <span class="token keyword">var</span> pviot <span class="token builtin">int</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">//保存函数中传入的l原值</span>    <span class="token keyword">var</span> left <span class="token builtin">int</span><span class="token operator">=</span>l    <span class="token comment" spellcheck="true">//保存函数中传入的r原值</span>    <span class="token keyword">var</span> right <span class="token builtin">int</span><span class="token operator">=</span>r    <span class="token comment" spellcheck="true">//循环排序</span>    <span class="token keyword">for</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//基准值选了待排序部分最左边，所以从r开始</span>        <span class="token comment" spellcheck="true">//如果右边得值大于基准值，不用与左边交换，只需r减小，直到右边的值小于基准值</span>        <span class="token keyword">for</span> pviot<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">{</span>            r<span class="token operator">--</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//此时右边所指的数小于左边，需要将右边得值赋给左边</span>        <span class="token keyword">if</span> r<span class="token operator">></span>l<span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> pviot<span class="token operator">>=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">{</span>            l<span class="token operator">++</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> r<span class="token operator">></span>l<span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//此时l和r指向同一个数字，把基准值放在此处</span>    nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>pviot    <span class="token comment" spellcheck="true">//对基准值左边进行快速排序</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>l<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//对基准值右边进行快速排序</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想：归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法的一个非常典型的应用，且各层分治递归可以同时进行。</p><ul><li>分解（Divide）： 将n个元素分成个含n/2个元素的子序列。</li><li>解决（Conquer）：用合并排序法对两个子序列递归的排序。</li><li>合并（Combine）：合并两个已排序的子序列已得到排序结果。</li></ul><h4 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h4><p><img src="../img/7789414-b410a7c0fea50eba.png" alt=""></p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li>对待排序部分分为左右两部分</li><li>对左边部分递归进行归并排序</li><li>对右边部分递归进行归并排序</li><li>对这两部分进行合并</li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>l <span class="token builtin">int</span><span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> l<span class="token operator">>=</span>r<span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> middle <span class="token builtin">int</span><span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>    <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>middle<span class="token punctuation">)</span>    <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span>    <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>middle<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">merge</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>l <span class="token builtin">int</span><span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">,</span>middle <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> temp <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span><span class="token operator">=</span><span class="token number">0</span>    <span class="token keyword">var</span> j <span class="token builtin">int</span><span class="token operator">=</span>l    <span class="token keyword">var</span> k <span class="token builtin">int</span><span class="token operator">=</span>middle<span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">for</span> j<span class="token operator">&lt;=</span>middle<span class="token operator">&amp;&amp;</span>k<span class="token operator">&lt;=</span>r<span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j<span class="token operator">++</span>            i<span class="token operator">++</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>            k<span class="token operator">++</span>            i<span class="token operator">++</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> j<span class="token operator">&lt;=</span>middle<span class="token punctuation">{</span>        temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        j<span class="token operator">++</span>        i<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> k<span class="token operator">&lt;=</span>r<span class="token punctuation">{</span>        temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        k<span class="token operator">++</span>        i<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>l<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>思想：工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序，有可能再使用别的排序算法或是以递归方式继续使用桶排序</p><h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里面去；</li><li>对每个不是空的桶进行排序。</li><li>从不是空的桶里面把排序好的数据进行拼接；</li></ul><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>思想：它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h5 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h5><ol><li>将第一个元素视为已经排序</li><li>从第一个元素开始依次向后取出元素，与它前面已经排序的序列比较，将它插入到合适的位置</li></ol><h5 id="图解-3"><a href="#图解-3" class="headerlink" title="图解"></a>图解</h5><p><img src="../img/insertSort.jpg" alt=""></p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>cur <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> cur<span class="token operator">>=</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> temp <span class="token builtin">int</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span>    <span class="token keyword">for</span> i<span class="token operator">=</span>cur<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span>temp <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp            <span class="token keyword">break</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">InsertSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="希尔排序（shell-sort）"><a href="#希尔排序（shell-sort）" class="headerlink" title="希尔排序（shell sort）"></a>希尔排序（shell sort）</h4><p>思想:希尔排序算是对简单插入排序的一种改进，属于一种增量式的排序算法，通过对数组”分组微调”,使大部分元素有序，减少插入排序的工作量</p><h5 id="图解-4"><a href="#图解-4" class="headerlink" title="图解"></a>图解</h5><p><img src="../img/shellsort.png" alt=""></p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> n <span class="token builtin">int</span><span class="token operator">=</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>    <span class="token keyword">for</span> n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span>n<span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>            <span class="token keyword">var</span> temp <span class="token builtin">int</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">var</span> tag <span class="token builtin">int</span><span class="token operator">=</span>i<span class="token operator">-</span>n            <span class="token keyword">for</span> tag<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token operator">></span>temp<span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>tag<span class="token operator">+</span>n<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>tag<span class="token punctuation">]</span>                tag<span class="token operator">=</span>tag<span class="token operator">-</span>n            <span class="token punctuation">}</span>            nums<span class="token punctuation">[</span>tag<span class="token operator">+</span>n<span class="token punctuation">]</span><span class="token operator">=</span>temp        <span class="token punctuation">}</span>        n<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/04/hello-world/"/>
      <url>/2020/07/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
