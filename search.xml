<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kubernetes</title>
      <link href="/2021/02/21/kubernetes/"/>
      <url>/2021/02/21/kubernetes/</url>
      
        <content type="html"><![CDATA[<h4 id="kubernetes由来"><a href="#kubernetes由来" class="headerlink" title="kubernetes由来"></a>kubernetes由来</h4><p>kubernetes是由google开源的一款容器自动化编排工具，可以轻松地管理容器集群。kubernetes在希腊语中是舵手的意思，它的前身是Google的borg系统。</p><h4 id="kubernetes核心功能"><a href="#kubernetes核心功能" class="headerlink" title="kubernetes核心功能"></a>kubernetes核心功能</h4><ol><li>服务发现与负载均衡   </li><li>自动容器恢复</li><li>存储编排</li><li>容器自动装箱</li><li>自动发布与回滚</li><li>配置与密文管理</li><li>批量执行</li><li>水平伸缩<br><img src="/2021/02/21/kubernetes/kubernetes%E7%BB%93%E6%9E%84.jpg" alt></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new</title>
      <link href="/2020/12/01/new/"/>
      <url>/2020/12/01/new/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/UDP协议</title>
      <link href="/2020/11/28/TCP-UDP/"/>
      <url>/2020/11/28/TCP-UDP/</url>
      
        <content type="html"><![CDATA[<h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。分为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><p><img src="/2020/11/28/TCP-UDP/OSI.png" alt=""></p><p>OSI七层模型在TCP/ip协议中并未完全被实现，其中的应用层/表示层/会话层在TCP/ip协议中一起包含在应用层中。</p><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><ol><li>TCP提供一种面向连接的、可靠的字节流服务。</li><li>在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP</li><li>TCP使用校验和，确认和重传机制来保证可靠传输</li><li>TCP给数据分节进行排序，并使用累计确认保证数据的顺序不变和非重复</li><li>TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li><li>TCP提供全双工通信。（发送缓存和接收缓存）</li></ol><h5 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h5><ol><li>确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。</li><li>数据校验</li><li>数据合理分片和排序</li><li>流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</li><li>拥塞控制：当网络拥塞时，减少数据的发送。</li></ol><h4 id="TCP协议三次握手四次挥手"><a href="#TCP协议三次握手四次挥手" class="headerlink" title="TCP协议三次握手四次挥手"></a>TCP协议三次握手四次挥手</h4><p>TCP协议在进行连接时，会进行三次握手。client向server发送一个SYN(i)<br>包并进入SYN_SENT状态，等待服务器确认;server收到后返回一个ACK(i+1)包同时还返回一个SYN(k)包即SYN+ACK包，此时服务器进入SYN_RECV状态;client在接收到服务器返回客户端收到服务器的SYN+ACK包后，返回一个ACK(k+1)包。client返回ACK包后客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手</p><p>TCP协议可以设计为四次握手，但是会浪费资源，三次已经足够了。<br><img src="/2020/11/28/TCP-UDP/TCP.jpg" alt=""></p><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>TCP协议在断开连接时，会进行四次挥手。首先Client会向server发送一个FIN(i)包，变成Fin_WAIT1状态;</p><p>server在收到FIN(i)包后会返回一个ACK(i+1)包，服务器变成CLOSED_WAIT状态；</p><p>由于服务器在返回ACK(i+1)包的时候可能还在传输数据，所以在服务器传输完数据之后，服务器还会再返回一个FIN(k)包，并进入到LAST-ACK状态，等待客户端的确认。</p><p>客户端再返回一个ACk(K+1)包，然后进入TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后才会断开。</p><p>当客户端撤销相应的TCB后，才进入CLOSED状态，服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。</p><p>服务器结束TCP连接的时间要比客户端早一些。MSL是TCP报文的最大生存时间, 因此TIME_WAIT持续存在2MSL的话就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失，1、防止最后一个ACK对方没有收到，2、刚刚回收的五元组，保留一段时间在分配。</p><p><img src="/2020/11/28/TCP-UDP/TCP_OSI.png" alt=""></p><h4 id="TCP连接过程中的名词"><a href="#TCP连接过程中的名词" class="headerlink" title="TCP连接过程中的名词"></a>TCP连接过程中的名词</h4><ol><li><p>序列号seq<br>占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生，给字节编上序号后，就给每一个报文段指派一个序号，序列号seq就是这个报文段中的第一个字节的数据编号。</p></li><li><p>确认号ack<br>占4个字节，期待收到对方下一个报文段的第一个数据字节的序号，序列号表示报文段携带数据的第一个字节的编号，而确认号指的是期望接受到下一个字节的编号，因此挡墙报文段最后一个字节的编号+1即是确认号。</p></li><li><p>确认ACK<br>占1个比特位，仅当ACK=1，确认号字段才有效。ACK=0，确认号无效。</p></li><li><p>同步SYN<br>连接建立时用于同步序号。当SYN=1，ACK=0表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使用SYN=1，ACK=1.因此，SYN=1表示这是一个连接请求，或连接接收报文，SYN这个标志位只有在TCP建立连接才会被置为1，握手完成后SYN标志位被置为0.</p></li><li><p>终止FIN<br>用来释放一个</p></li></ol><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>UDP，用户数据包协议，又称不可靠数据包协议，顾名思义，就是不能保证数据一定能传输到目标机器</p><p>UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。<br>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息，并且低延时。<br>UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。<br>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。<br>UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。<br>UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</p><p>UDP的数据包并没有序列，所以，UDP不保证消息交付顺序，并且不确认，不重传，不排重，随心所欲，有包就发，不像TCP会优先发队首。UDP不跟踪连接状态，不建立连接也不关心对方是否能收到！UDP不需要流量控制，不管网络的情况，没有拥塞控制。</p><h4 id="TCP协议与UDP协议的区别"><a href="#TCP协议与UDP协议的区别" class="headerlink" title="TCP协议与UDP协议的区别"></a>TCP协议与UDP协议的区别</h4><p>二、TCP与UDP的区别。<br>①连接方面：TCP面向连接，UDP是无连接的<br>②安全方面：TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。UDP尽最大努力交付，即不保证可靠交付。<br>③传输效率：TCP传输效率相对较低。UDP传输效率高，适用于对高速传输和实时性有较高的通信或广播通信。<br>④连接对象数量：TCP连接只能是点到点、一对一的。<br>UDP支持一对一，一对多，多对一和多对多的交互通信。</p><h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><p>在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.<br>Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。<br>Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.在Linux下可以如下命令检测是否被Syn攻击<br>netstat -n -p TCP | grep SYN_RECV<br>一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等.<br>但是不能完全防范syn攻击。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> UDP </tag>
            
            <tag> TCP </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang内建函数</title>
      <link href="/2020/11/17/builtinfunction/"/>
      <url>/2020/11/17/builtinfunction/</url>
      
        <content type="html"><![CDATA[<p>在go语言中，有不少内建函数，本篇文章主要是梳理go语言中的几个常用的内建函数的使用场景和各个函数之间的区别。</p><h4 id="make"><a href="#make" class="headerlink" title="make()"></a>make()</h4><p>make函数可以分配内存，但是只能适用于切片slice、hash表map、信道chanel</p><ul><li><p>创建切片：</p><ul><li>参数：类型和容量，此时长度和容量相等<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li>参数：类型、长度、容量<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul></li><li><p>创建map：</p><ul><li>参数：类型，只传入类型时长度为零<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> nums <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li><li>参数：类型、长度，创建的map初始长度还是0，但是分配了初始的空间映射，可以继续扩展增加，貌似没什么特别的作用<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> nums <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul></li><li><p>创建chanel:</p><ul><li><p>参数：类型，不带缓冲的信道</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> nums <span class="token keyword">chan</span>  <span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">test</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>nums <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    nums<span class="token operator">&lt;-</span><span class="token number">1</span>    nums<span class="token operator">&lt;-</span><span class="token number">2</span>    nums<span class="token operator">&lt;-</span><span class="token number">3</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>nums<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><p>参数：类型，长度。带长度的有缓存信道</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> nums <span class="token keyword">chan</span>  <span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">test</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>nums <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    nums<span class="token operator">&lt;-</span><span class="token number">1</span>    nums<span class="token operator">&lt;-</span><span class="token number">2</span>    nums<span class="token operator">&lt;-</span><span class="token number">3</span>    nums<span class="token operator">&lt;-</span><span class="token number">3</span>    nums<span class="token operator">&lt;-</span><span class="token number">3</span>    nums<span class="token operator">&lt;-</span><span class="token number">3</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>nums<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><p>需要注意的是，不带缓冲的chanel在make后只能在协程中使用，否则会报死锁，带缓冲的则不会报死锁，以下代码会报错</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> nums <span class="token keyword">chan</span>  <span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    nums<span class="token operator">&lt;-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//报错信息</span>fatal <span class="token builtin">error</span><span class="token punctuation">:</span> all goroutines are asleep <span class="token operator">-</span> deadlock<span class="token operator">!</span>goroutine <span class="token number">1</span> <span class="token punctuation">[</span><span class="token keyword">chan</span> send<span class="token punctuation">]</span><span class="token punctuation">:</span>main<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    G<span class="token punctuation">:</span><span class="token operator">/</span>code<span class="token operator">/</span>gocode<span class="token operator">/</span>PDFdemo<span class="token operator">/</span>main<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">34</span> <span class="token operator">+</span><span class="token number">0x57</span></code></pre></li></ul></li></ul><h4 id="new"><a href="#new" class="headerlink" title="new():"></a>new():</h4><p>new()是用来分配空间的，返回值是指针类型，可以理解为面向对象语言中创建对象的操作。</p><ul><li><p>参数：类型</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> test <span class="token keyword">struct</span> <span class="token punctuation">{</span>      name <span class="token builtin">string</span>  <span class="token punctuation">}</span>  <span class="token keyword">var</span> t <span class="token operator">*</span>test<span class="token operator">=</span><span class="token function">new</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//编译器会自动给t加上*，所以使用t的时候可以不加*,在这里t和*t效果等同</span>  t<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"hello"</span>  <span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">10</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span></code></pre></li></ul><h4 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h4><p>len()是用来测数组、切片、map、chanel的长度的</p><ul><li><p>测数组，</p><pre class=" language-go"><code class="language-go">  <span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//输出</span>  <span class="token number">7</span></code></pre><pre class=" language-go"><code class="language-go">  <span class="token comment" spellcheck="true">//测数组指针时，是指针指向的数组的长度</span>  <span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span>  <span class="token keyword">var</span> temp <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token operator">&amp;</span>nums  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token operator">*</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//输出7</span>  <span class="token comment" spellcheck="true">//待测数组是指针数组时，测得是数组的长度</span>  <span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span>  <span class="token keyword">var</span> temp <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token operator">&amp;</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//输出2</span></code></pre></li><li><p>测切片</p><pre class=" language-go"><code class="language-go">  <span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//输出</span>  <span class="token number">7</span></code></pre></li><li><p>测map</p><pre class=" language-go"><code class="language-go">  <span class="token keyword">var</span> set <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int8</span><span class="token punctuation">]</span><span class="token builtin">int8</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int8</span><span class="token punctuation">]</span><span class="token builtin">int8</span><span class="token punctuation">)</span>  set<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//输出</span>  <span class="token number">1</span></code></pre></li><li><p>测chanel:返回值是chanel元素个数</p><pre class=" language-go"><code class="language-go">  <span class="token keyword">var</span> temp <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>  temp<span class="token operator">&lt;-</span><span class="token number">1</span>  temp<span class="token operator">&lt;-</span><span class="token number">2</span>  temp<span class="token operator">&lt;-</span><span class="token number">3</span>  temp<span class="token operator">&lt;-</span><span class="token number">4</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//输出4，元素有四个，而不是输出容量8</span></code></pre></li></ul><h4 id="cap"><a href="#cap" class="headerlink" title="cap()"></a>cap()</h4><p>cap()函数是用来测数组、切片、chanel的长度的</p><ul><li>测数组：返回数组长度<pre class=" language-go"><code class="language-go">  <span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li><li>测切片：返回切片的容量<pre class=" language-go"><code class="language-go">  <span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//输出10</span></code></pre></li><li>测chanel：返回chanel容量<pre class=" language-go"><code class="language-go">  <span class="token keyword">var</span> temp <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>  temp<span class="token operator">&lt;-</span><span class="token number">1</span>  temp<span class="token operator">&lt;-</span><span class="token number">2</span>  temp<span class="token operator">&lt;-</span><span class="token number">3</span>  temp<span class="token operator">&lt;-</span><span class="token number">4</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul><h4 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h4><p>append()函数主要是用来给slice添加元素的，也可以给字符串添加元素(需要先将元素转为byte数组)</p><ul><li><p>给切片扩容</p><pre class=" language-go"><code class="language-go">    <span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>    nums<span class="token operator">=</span><span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//添加一个切片时，后面需要加...</span>    nums<span class="token operator">=</span><span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token punctuation">)</span></code></pre></li><li><p>拼接字符串</p><pre class=" language-go"><code class="language-go">  <span class="token keyword">var</span> str <span class="token builtin">string</span><span class="token operator">=</span><span class="token string">"hello"</span>  <span class="token comment" spellcheck="true">//用法可行，但是没有直接用加号拼接方便</span>  str<span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">" world!"</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span></code></pre></li><li><p>delete()<br>delete()函数用来删除map中的元素</p><pre class=" language-go"><code class="language-go">  <span class="token keyword">var</span> temp <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>  temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>  temp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token function">delete</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span>temp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  val<span class="token punctuation">,</span>ok<span class="token operator">:=</span>temp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token keyword">if</span> ok <span class="token punctuation">{</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token punctuation">}</span></code></pre></li><li><p>close()<br>close函数主要是用来关闭chanel的</p><pre class=" language-go"><code class="language-go">  <span class="token keyword">var</span> temp <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>  temp<span class="token operator">&lt;-</span><span class="token number">1</span>  temp<span class="token operator">&lt;-</span><span class="token number">2</span>  temp<span class="token operator">&lt;-</span><span class="token number">3</span>  temp<span class="token operator">&lt;-</span><span class="token number">4</span>  <span class="token function">close</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础强化</title>
      <link href="/2020/09/20/mysql/"/>
      <url>/2020/09/20/mysql/</url>
      
        <content type="html"><![CDATA[<p>声明：此博客很大一部分摘抄自<a href="https://www.runoob.com/，做此总结是为了应对面试以及补全基础所用" target="_blank" rel="noopener">https://www.runoob.com/，做此总结是为了应对面试以及补全基础所用</a></p><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>常见的有5种。</p><ul><li>count()：按规则统计列的数量</li><li>sum():按规则求和</li><li>min():求最小值</li><li>max():求最大值</li><li>avg():统计平均值</li></ul><p>不是特别常见的聚合函数(面试可能问到)</p><ul><li>last():返回指定的列中最后一个记录的值</li><li>len():返回文本字段中值的长度</li><li>now():返回当前系统的日期和时间</li><li>mid():用于从文本字段中提取字符 </li></ul><p>其它聚合函数还要很多</p><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><p>事务有以下几种特性(简称ACID)：</p><ul><li><p>原子性(A-Atomicity)：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p>一致性(C-Consistency)：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p>隔离性(I-Isolation)：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p>持久性(D-Durability)：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><p>数据库中事务的作用：</p><ol><li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li><li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li><li>事务用来管理 insert,update,delete 语句</li></ol><p>MYSQL 事务处理主要有两种方法：</p><ol><li><p>用 BEGIN, ROLLBACK, COMMIT来实现</p><p> BEGIN 开始一个事务</p><p> ROLLBACK 事务回滚</p><p> COMMIT 事务确认</p></li><li><p>直接用 SET 来改变 MySQL 的自动提交模式:</p><p> SET AUTOCOMMIT=0 禁止自动提交</p><p> SET AUTOCOMMIT=1 开启自动提交</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4></li></ol><p>索引可以大大提高MySQL的检索速度。索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列</p><p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p><p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。<br>                                   建立索引会占用磁盘空间的索引文件。</p><p>索引失效问题</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><h4 id="mysql-集群-占位-以后更新"><a href="#mysql-集群-占位-以后更新" class="headerlink" title="mysql-集群 占位(以后更新)"></a>mysql-集群 占位(以后更新)</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 聚合函数 </tag>
            
            <tag> 存储过程 </tag>
            
            <tag> 事务 </tag>
            
            <tag> 索引 </tag>
            
            <tag> 视图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议补漏</title>
      <link href="/2020/09/17/httpmethed/"/>
      <url>/2020/09/17/httpmethed/</url>
      
        <content type="html"><![CDATA[<h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）</p><h4 id="http请求报文的结构"><a href="#http请求报文的结构" class="headerlink" title="http请求报文的结构"></a>http请求报文的结构</h4><p>一个HTTP请求包含了请求行、请求头、空行、请求数据(GET等不携带信息的请求没有这部分)四部分组成<br><img src="../img/httpstruct.jpg" alt=""></p><h4 id="HTTP响应报文的结构"><a href="#HTTP响应报文的结构" class="headerlink" title="HTTP响应报文的结构"></a>HTTP响应报文的结构</h4><p>一个HTTP响应报文，由首行、响应头、空行、响应体组成，</p><h4 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h4><p>http协议共有9种请求方式，在http 1.0中只有GET、POST、HEAD这三种请求方法，在HTTP 1.1中有增加了6种，共有9种而不是目前众多博客上所称的8种，个人验证之后确实是9种。</p><p><img src="../img/httprequest.jpg" alt=""><br>(图片来源于菜鸟教程)</p><h4 id="HTTP协议与HTTPS协议的区别"><a href="#HTTP协议与HTTPS协议的区别" class="headerlink" title="HTTP协议与HTTPS协议的区别"></a>HTTP协议与HTTPS协议的区别</h4><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</p><p>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h4 id="http1-0与http1-1的区别"><a href="#http1-0与http1-1的区别" class="headerlink" title="http1.0与http1.1的区别"></a>http1.0与http1.1的区别</h4><p> 1、HTTP 1.0中浏览器与服务器只保持短暂的连接，浏览器的每次请求都与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</p><p> 2、http1.1提供永久性连接（即1.0使用非持久连接，HTTP1.0没有host的字段).</p><p> 3、HTTP 1.1中增加Host请求头字段后，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。</p><p> 4、http1.1提供身份认证（HTTP1.1提供一个基于口令的基本认证方式，）</p><h4 id="HTTP常见的状态码"><a href="#HTTP常见的状态码" class="headerlink" title="HTTP常见的状态码"></a>HTTP常见的状态码</h4><ul><li>200:请求成功</li><li>300:请求重定向</li><li>404:资源不存在</li><li>500:服务器出错<br><img src="/2020/09/17/httpmethed/img/HTTPstaus.jpg" alt=""></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protobuf</title>
      <link href="/2020/09/10/protobuf/"/>
      <url>/2020/09/10/protobuf/</url>
      
        <content type="html"><![CDATA[<p>go语言中使用protobuf需要有相应的环境。</p><h4 id="1-安装protobuf编译器"><a href="#1-安装protobuf编译器" class="headerlink" title="1.安装protobuf编译器"></a>1.安装protobuf编译器</h4><p>在protobuf的Git主页上，下载相应的release版本,解压即可使用</p><h4 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h4><p>将protobuf的bin目录添加到path中即可</p><h4 id="3-下载protobuf-gen-go库"><a href="#3-下载protobuf-gen-go库" class="headerlink" title="3.下载protobuf-gen-go库"></a>3.下载protobuf-gen-go库</h4><p>执行以下命令：</p><pre class=" language-shell"><code class="language-shell">go get github.com/golang/protobuf/protoc-gen-gogo get google.golang.org/protobuf/protogo install google.golang.org/protobuf/cmd/protoc-gen-go</code></pre><h4 id="Protobuf协议语法"><a href="#Protobuf协议语法" class="headerlink" title="Protobuf协议语法"></a>Protobuf协议语法</h4><ul><li>文件以.proto为扩展名</li><li>message定义一个消息</li><li>用enum定义一个枚举</li><li>以syntax = “proto2”;的形式声明使用的版本</li><li>以”;”来结尾</li><li>以//和/**/注释</li><li>字段修饰符有三种:required、optional、 repeated</li><li>以package关键字打包</li><li>以import “XXX.proto”的方式</li><li>数据类型跟go类似</li><li>每个字段都需要分配标识符(相当于顺序)，标识符不可以取19000-19999之间(已经被预留)，最大是536870911<pre class=" language-protobuf"><code class="language-protobuf">syntax <span class="token operator">=</span> <span class="token string">"proto2"</span><span class="token punctuation">;</span><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"hello.proto"</span><span class="token punctuation">;</span><span class="token keyword">message</span> Order<span class="token punctuation">{</span><span class="token builtin">required</span> <span class="token primitive symbol">int32</span> order_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token builtin">required</span> <span class="token primitive symbol">int32</span> order_number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token builtin">required</span> <span class="token primitive symbol">string</span> timestamp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>等号后面的数字是指序列化时的顺序，而不是赋值。</li></ul><p>required表示是必须要包含的，optional表示可选的，传输时可包含可不包含,repeated这种字段可以重复任意多次，重复的值的顺序会被保留。</p><p>编译.proto文件时，在命令行输入以下命令：</p><pre class=" language-shell"><code class="language-shell">protoc --go_out=. te.proto</code></pre><p>go语言的一个小demo</p><pre class=" language-shell"><code class="language-shell">package mainimport (    "fmt"    "google.golang.org/protobuf/proto"    "design/test")func main(){    order :=test.Order{        OrderId:     1,        OrderNumber: 2,        Timestamp:   "2020/9/11",    }    oederEnty,_:=proto.Marshal(&order)    o1 :=&test.Order{}    proto.Unmarshal(oederEnty,o1)    fmt.Println(o1)}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> protobuf </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC</title>
      <link href="/2020/09/10/rpc/"/>
      <url>/2020/09/10/rpc/</url>
      
        <content type="html"><![CDATA[<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>RPC是远程过程调用（Remote Procedure Call）的缩写形式，是一种计算机通信协议，可以让不同主机上的不同程序实现通信和调用。</p><p><img src="/2020/09/10/rpc/img/RPC1.jpg" alt=""></p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><p>不同编程语言的程序之间可以通信，使得各种业务可以使用最适合的语言进行处理</p><h4 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h4><p>采用微服务架构时，需要与其它服务通讯，这种通讯方式是进程之间的通信(Inter-Process Communication)</p><p>微服务需要有服务注册功能，以便自动管理服务的上线和下线</p><h5 id="IPC的实现"><a href="#IPC的实现" class="headerlink" title="IPC的实现"></a>IPC的实现</h5><p>IPC有两种实现</p><p>1 同步过程调用</p><ul><li>REST:REST基于http，实现容易，多语言支持</li><li>RPC:RPC的传输效率高，安全性可控，多用于系统内部调用</li></ul><p>2 异步消息调用</p><ul><li>Kafaka(常用框架)</li><li>Notify(常用框架)</li><li>MessageQueue(常用框架)</li></ul><p>同步过程调用比较简单，但是安全性和可靠性要差一些</p><p>异步消息调用在分布式中应用广泛，可以降低调用服务之间的耦合，还可以成为调用之间的缓冲。但是一致性会减弱，会有时延。还必须引入独立的broker作为中间代理池。</p><h4 id="RPC的实现步骤"><a href="#RPC的实现步骤" class="headerlink" title="RPC的实现步骤"></a>RPC的实现步骤</h4><ol><li>client调用client stub，这是一次本地调用过程</li><li>client stub将参数打包成一个消息，打包的过程称为marshalling</li><li>client所在的系统将消息发给server</li><li>server坐在的系统将受到的包传给server stub</li><li>server stub将受到的包解包，称为unmarshalling</li><li>server stub调用服务过程，返回结果按照相反的步骤传给client</li></ol><p>带来的新问题：</p><ol><li>Call ID映射</li><li>序列化与烦序列化</li><li>网络传输</li></ol><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><p>Google的protocol buffer简称为Protobuf，是谷歌内部的混合语言数据标准，主要用于RPC系统和持续数据存储系统。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>性能好效率高</li><li>代码生成机制</li><li>支持向前兼容和向后兼容</li><li>多语言支持</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> go语言 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSQ</title>
      <link href="/2020/09/09/NSQ/"/>
      <url>/2020/09/09/NSQ/</url>
      
        <content type="html"><![CDATA[<p>NSQ是一个高性能的用go语言实现的开源消息队列。</p><h4 id="NSQ特性"><a href="#NSQ特性" class="headerlink" title="NSQ特性"></a>NSQ特性</h4><ul><li><p>消息默认不持久化，想要进行持久化需要自己进行配置，采用的内存加硬盘模式，内存中的数据量达到一定程度时就会持久化到硬盘中</p></li><li><p>将 –mem-queue-size设置为0时，所有消息都会持久化的</p></li><li><p>关闭时也会持久化</p></li><li><p>每条消息至少传递一次</p></li><li><p>消息不保证有序</p></li></ul><h4 id="NSQ三种角色"><a href="#NSQ三种角色" class="headerlink" title="NSQ三种角色"></a>NSQ三种角色</h4><h5 id="NSQD"><a href="#NSQD" class="headerlink" title="NSQD"></a>NSQD</h5><p>nsqd是一个守护进程，负责接收、排队、并向客户端发送消息</p><h5 id="NSQLOOKUPD"><a href="#NSQLOOKUPD" class="headerlink" title="NSQLOOKUPD"></a>NSQLOOKUPD</h5><p>管理拓扑信息, 用于收集nsqd上报的topic和channel,并提供最终一致性的发现服务的守护进程</p><h5 id="NSQADMIN"><a href="#NSQADMIN" class="headerlink" title="NSQADMIN"></a>NSQADMIN</h5><p>一套Web用户界面，可实时查看集群的统计数据和执行相应的管理任务</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> NSQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构</title>
      <link href="/2020/09/08/architecture/"/>
      <url>/2020/09/08/architecture/</url>
      
        <content type="html"><![CDATA[<p>互联网架构演进是十分迅速的，为了应对越来越高的要求，不断诞生新的理论和架构，下图就是主流的架构演变历史<br><img src="/2020/09/08/architecture/img/architecture.jpg" alt=""></p><h4 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h4><p>单体架构是最早期的架构，将数据库、服务器处理、前端展示这些部分集成在一个应用中的（系统中所有的功能、模块耦合在一个应用中的架构方式），就算是单体架构。mvc结构就是典型的单体架构。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>开发效率高，项目易于管理</li><li>所有功能耦合在一起，部署简单</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>所有功能打包在一个应用中，服务器压力较大，容受制于服务器的性能瓶颈</li><li>服务器挂掉，所有功能都无法使用</li><li>代码会越来越臃肿，管理成本不断增加</li></ol><h4 id="水平分层架构"><a href="#水平分层架构" class="headerlink" title="水平分层架构"></a>水平分层架构</h4><p>单体架构进行水平拆分，就形成了水平分层架构。可拆分为网关层、业务层、数据层。</p><h5 id="网关层"><a href="#网关层" class="headerlink" title="网关层"></a>网关层</h5><p>网关层主要有以下作用</p><ol><li>请求鉴权</li><li>数据完整性检查</li><li>协议转换</li><li>路由转发</li><li>服务治理</li></ol><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>分层结构的优点：</p><ol><li>分离开发人员的关注</li><li>降低了系统间的依赖</li><li>可以无损替换</li><li>易于复用</li></ol><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>分层架构有以下的缺点：</p><ol><li>分层会带来性能的损失</li><li>联级修改问题</li><li>不适合API频繁变动的业务</li></ol><h4 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h4><p>SOA架构全称 Service Oriented Architecture(面向服务架构)即从垂直方向上进行拆分</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ol><li>降低用户成本</li><li>程序之间关系服务简单</li></ol><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol><li>系统复杂度增加</li><li>性能有影响</li></ol><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>微服务架构风格是一个系统，由一套独立运行的微服务组成， 这些服务是围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制（通常是HTTP资源的API），可以全自动独立部署，可以使用不同的编程语言和数据存储技术。</p><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ol><li>伸缩性和扩展性比较高</li><li>部署和维护成本变低</li><li>有效解耦</li></ol><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ol><li>服务之间的隔离会造成数据孤岛问题</li><li>团队沟通的过载</li><li>DevOps的复杂度</li><li>增加了资源使用</li></ol><p>微服务需要有zookeeper这种框架来管理服务。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go_redis</title>
      <link href="/2020/09/07/go-redis/"/>
      <url>/2020/09/07/go-redis/</url>
      
        <content type="html"><![CDATA[<h4 id="下载连接redis的开源库"><a href="#下载连接redis的开源库" class="headerlink" title="下载连接redis的开源库"></a>下载连接redis的开源库</h4><p>在命令行输入go get github.com/go-redis/redis,结果如下</p><pre class=" language-shell"><code class="language-shell">E:\code\go\src\design>go get github.com/go-redis/redisgo: downloading github.com/go-redis/redis v6.15.9+incompatiblego: github.com/go-redis/redis upgrade => v6.15.9+incompatible</code></pre><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>在代码中导入go-redis库</p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"github.com/go-redis/redis"</span></code></pre><p>在代码中连接redis并进行测试</p><pre class=" language-go"><code class="language-go">    conf <span class="token operator">:=</span><span class="token function">new</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span>Options<span class="token punctuation">)</span>    conf<span class="token punctuation">.</span>Addr<span class="token operator">=</span><span class="token string">"101.37.xx.xx:6379"</span>    conf<span class="token punctuation">.</span>Password<span class="token operator">=</span><span class="token string">"xxxx"</span>    client <span class="token operator">:=</span>redis<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span>conf<span class="token punctuation">)</span>    pong<span class="token punctuation">,</span>err <span class="token operator">:=</span>client<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"连接成功，%v"</span><span class="token punctuation">,</span>pong<span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> go语言 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis配置</title>
      <link href="/2020/09/01/redis-config/"/>
      <url>/2020/09/01/redis-config/</url>
      
        <content type="html"><![CDATA[<h4 id="启动设置"><a href="#启动设置" class="headerlink" title="启动设置"></a>启动设置</h4><p>将redis下的文件redis.conf备份一份，修改时直接修改原本的配置文件，将Redis改为后台启动(默认启动的方式不是后台启动)</p><p>将Redis.conf中daemonize由no改为yes</p><pre class=" language-shell"><code class="language-shell">################################# GENERAL ###################################### By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.#daemonize nodaemonize yes</code></pre><p>然后用修改过的配置文件启动，</p><pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ src]# ./redis-server ../redis.conf 5643:C 06 Sep 2020 23:42:14.977 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo5643:C 06 Sep 2020 23:42:14.977 # Redis version=6.0.7, bits=64, commit=00000000, modified=0, pid=5643, just started5643:C 06 Sep 2020 23:42:14.977 # Configuration loaded</code></pre><h4 id="RDB配置"><a href="#RDB配置" class="headerlink" title="RDB配置"></a>RDB配置</h4><p>RDB的相关配置很多，主要配置的是触发规则</p><pre class=" language-shell"><code class="language-shell">#   save ""save 900 1save 300 10save 60 10000# 第一个数是时间，第二个是修改次数#比如save 60 10000就是60秒内修改了10000次触发</code></pre><p>rdb触发之后默认是在redis/src目录下生成的dump.rdb文件，重启之后会自动恢复数据</p><pre class=" language-shell"><code class="language-shell"># The filename where to dump the DBdbfilename dump.rdb</code></pre><h4 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h4><p>AOF机制需要自己手动开启，可以在redis.conf里面进行配置,将appendonly改成yes就可以了，重启之后会自动生成一个appendonly.aof文件</p><pre class=" language-shell"><code class="language-shell">############################## APPEND ONLY MODE ################################ By default Redis asynchronously dumps the dataset on disk. This mode is# good enough in many applications, but an issue with the Redis process or# a power outage may result into a few minutes of writes lost (depending on# the configured save points).## The Append Only File is an alternative persistence mode that provides# much better durability. For instance using the default data fsync policy# (see later in the config file) Redis can lose just one second of writes in a# dramatic event like a server power outage, or a single write if something# wrong with the Redis process itself happens, but the operating system is# still running correctly.## AOF and RDB persistence can be enabled at the same time without problems.# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information.appendonly no# The name of the append only file (default: "appendonly.aof")appendfilename "appendonly.aof"</code></pre><p>AOF的规则需要自己进行设置,规则有很多</p><pre class=" language-shell"><code class="language-shell"># Automatic rewrite of the append only file.# Redis is able to automatically rewrite the log file implicitly calling# BGREWRITEAOF when the AOF log size grows by the specified percentage.## This is how it works: Redis remembers the size of the AOF file after the# latest rewrite (if no rewrite has happened since the restart, the size of# the AOF at startup is used).## This base size is compared to the current size. If the current size is# bigger than the specified percentage, the rewrite is triggered. Also# you need to specify a minimal size for the AOF file to be rewritten, this# is useful to avoid rewriting the AOF file even if the percentage increase# is reached but it is still pretty small.## Specify a percentage of zero in order to disable the automatic AOF# rewrite feature.auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb</code></pre><h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><h5 id="主从复制配置"><a href="#主从复制配置" class="headerlink" title="主从复制配置"></a>主从复制配置</h5><p>直接使用solve to 命令，重启之后设置会失效重新变回主节点</p><p>例如</p><pre class=" language-shell"><code class="language-shell">solve to 192.168.43.24 6379</code></pre><p>在配置文件中进行主从配置</p><pre class=" language-shell"><code class="language-shell"> replicaof <masterip> <masterport># If the master is password protected (using the "requirepass" configuration# directive below) it is possible to tell the replica to authenticate before# starting the replication synchronization process, otherwise the master will# refuse the replica request.# masterauth <master-password></code></pre><h5 id="哨兵模式配置"><a href="#哨兵模式配置" class="headerlink" title="哨兵模式配置"></a>哨兵模式配置</h5><p>在配置哨兵模式时，需要自己手动创建sentinel.conf（在redis6版本里面，会自带的sentinel.conf文件），文件名不能错</p><pre class=" language-shell"><code class="language-shell"># the replicas using additional configuration options.# Also note that the configuration file is rewritten when a# replica is promoted to master.## Note: master name should not include special characters or spaces.# The valid charset is A-z 0-9 and the three characters ".-_".sentinel monitor mymaster 127.0.0.1 6379 2#2表示需要2个sentinel才能判断客观下线,默认值是二#配置格式：sentinel <option_name> <master_name> <option_value></code></pre><p>启动哨兵节点时，在src目录下执行./redis-sentinel ../sentinel.conf就可以启动哨兵节点了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>database/sql包</title>
      <link href="/2020/08/20/databaseSql/"/>
      <url>/2020/08/20/databaseSql/</url>
      
        <content type="html"><![CDATA[<p>database/sql包是go语言官方提供的sql连接和使用的包，用以操作SQL和类SQL数据库，但是官方没有提供驱动，需要自己手动安装</p><h4 id="安装mysql驱动包"><a href="#安装mysql驱动包" class="headerlink" title="安装mysql驱动包"></a>安装mysql驱动包</h4><p>在终端输入以下命令,就能安装mysql的驱动包</p><pre class=" language-shell"><code class="language-shell">E:\code\go\src\design>go get github.com/go-sql-driver/mysqlgo: github.com/go-sql-driver/mysql upgrade => v1.5.0</code></pre><h4 id="导入相关包"><a href="#导入相关包" class="headerlink" title="导入相关包"></a>导入相关包</h4><p>在代码中导入database/sql包和驱动包,驱动包需要使用下划线导包的方式</p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"database/sql"</span>    <span class="token boolean">_</span> <span class="token string">"github.com/go-sql-driver/mysql"</span><span class="token punctuation">)</span></code></pre><h4 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h4><p>sql.Open()函数可以连接数据库，第一个参数是驱动名称，第二个参数是连接数据库必须要用到信息,DB不是连接，只有当需要使用时才会创建连接，如果想立即验证连接，需要用Ping()方法</p><pre class=" language-go"><code class="language-go">db<span class="token punctuation">,</span>err<span class="token operator">:=</span>sql<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"mysql"</span><span class="token punctuation">,</span><span class="token string">"user:password@tcp(127.0.0.1:3306)/database"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//fmt.Println("连接失败")</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> db<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    err <span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"状态错误"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><p>使用数据库查询语言时，先用rows对象(sql.go中定义的结构体)接收db.Query()查询的结果，然后使用rows对象的next方法进行迭代,rows使用完也需要使用close方法关闭资源，把遍历到的数据存入变量使用rows.Scan()</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> sql <span class="token builtin">string</span><span class="token operator">=</span><span class="token string">"select user_id,user_name from user;"</span>    <span class="token keyword">var</span><span class="token punctuation">(</span>        id <span class="token builtin">string</span>        name <span class="token builtin">string</span>    <span class="token punctuation">)</span>    rows<span class="token punctuation">,</span>err<span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"查询失败"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> rows<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> rows<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">:=</span>rows<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>id<span class="token punctuation">,</span><span class="token operator">&amp;</span>name<span class="token punctuation">)</span>        <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"查询失败"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s-----%s\n"</span><span class="token punctuation">,</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><p>在使用数据库操作语言的时候，使用db.Exec()方法可以执行insert、update、delete等语句</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> sqlStr<span class="token operator">=</span><span class="token string">"update user set user_name=? where user_id=?"</span>     result<span class="token punctuation">,</span>err<span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sqlStr<span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span>         fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"跟新失败"</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>     rows<span class="token punctuation">,</span>err<span class="token operator">:=</span>result<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>     fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>rows<span class="token punctuation">)</span></code></pre><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p>使用数据库定义语言的时候，同样是通过db.Exec()方法</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> sqlStr<span class="token operator">=</span><span class="token string">"create table test(id int not null,info varchar(100) not null)"</span>    res<span class="token punctuation">,</span>err<span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"err"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><p>数据库控制语言现阶段用得少，后面再补充</p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><h5 id="普通SQL语句的执行："><a href="#普通SQL语句的执行：" class="headerlink" title="普通SQL语句的执行："></a>普通SQL语句的执行：</h5><ol><li>客户端对SQL语句进行占位符替换的到完整的SQL语句</li><li>将完整的SQL语句发送到mysql服务端</li><li>mysql服务端执行SQL语句并返回结果</li></ol><h5 id="预处理的sql："><a href="#预处理的sql：" class="headerlink" title="预处理的sql："></a>预处理的sql：</h5><ol><li>将SQL语句分为命令部分和数据部分</li><li>先把命令部分发送给mysql服务端，mysql服务端进行SQL预处理</li><li>然后把数据部分发送给mysql服务端进行占位符替换</li><li>mysql执行完整的SQL语句并返回结果</li></ol><h5 id="预处理的好处："><a href="#预处理的好处：" class="headerlink" title="预处理的好处："></a>预处理的好处：</h5><ol><li>优化mysql重复执行sql的方法，可以提升服务器性能，提前编译之后，可以多次执行</li><li>可以避免SQL注入</li></ol><pre class=" language-go"><code class="language-go">        <span class="token keyword">var</span> sqlStr<span class="token operator">=</span><span class="token string">"select user_name from user where user_id&lt;3"</span>    statement<span class="token punctuation">,</span>err <span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Prepare</span><span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">defer</span> statement<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    rows<span class="token punctuation">,</span>err<span class="token operator">:=</span>statement<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> name <span class="token builtin">string</span>    <span class="token keyword">for</span> rows<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        err<span class="token operator">:=</span>rows<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>name<span class="token punctuation">)</span>        <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    rows<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>DML操作</p><pre class=" language-go"><code class="language-go">    <span class="token keyword">var</span> sqlStr<span class="token operator">=</span><span class="token string">"delete from user where user_id=?"</span>    statement<span class="token punctuation">,</span>err <span class="token operator">:=</span>db<span class="token punctuation">.</span><span class="token function">Prepare</span><span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">defer</span> statement<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    res<span class="token punctuation">,</span>err<span class="token operator">:=</span>statement<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    rowNum<span class="token punctuation">,</span>err <span class="token operator">:=</span>res<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"改变了%d行"</span><span class="token punctuation">,</span>rowNum<span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> go语言 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言包管理</title>
      <link href="/2020/08/20/goPackage/"/>
      <url>/2020/08/20/goPackage/</url>
      
        <content type="html"><![CDATA[<p>前言：在go语言中，有两种包管理方式gopath和go mod，导入自定义包和第三方包都需要准守一定的规则，并不是定义了包就能直接导入的。</p><h4 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h4><p>go语言安装第三方包的时候，直接用go get命令大部分时候会因为墙的问题无法安装成功，使用go mod包管理模式可以通过代理解决这个问题，设置代理是需要在终端执行以下命令</p><pre class=" language-shell"><code class="language-shell">go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct</code></pre><p>在go mod模式下，想要导入自定义包，需要创建go.mod文件，这样才可以成功导入并且使用自定义包</p><pre class=" language-shell"><code class="language-shell">go mod init</code></pre><p>go mod不依赖gopath，使用比较方便，还有以下一种常见命令<br><img src="/2020/08/20/goPackage/img/gomod.jpg" alt=""> </p><h4 id="gopath模式"><a href="#gopath模式" class="headerlink" title="gopath模式"></a>gopath模式</h4><p>gopath包管理方式是默认的管理方式，gopath包管理模式要求工程项目必须放在gopath下的src目录下，想要导入自定义包，需要先编译包，然后再安装包</p><pre class=" language-shell"><code class="language-shell">go build packagego install package</code></pre><h4 id="下划线导包"><a href="#下划线导包" class="headerlink" title="下划线导包"></a>下划线导包</h4><p>在go语言中，可以在包名前面加上下划线,这种做法只执行该库的 init 函数而不对其它导出对象进行真正地导入</p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"database/sql"</span>    <span class="token boolean">_</span><span class="token string">"github.com/go-sql-driver/mysql"</span><span class="token punctuation">)</span></code></pre><h4 id="点号导包"><a href="#点号导包" class="headerlink" title="点号导包"></a>点号导包</h4><p>这样的导包方式可以省略包名直接使用函数等</p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"github.com/lxn/walk"</span>    <span class="token punctuation">.</span> <span class="token string">"github.com/lxn/walk/declarative"</span>    <span class="token string">"strings"</span><span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2020/08/19/DesignPattern/"/>
      <url>/2020/08/19/DesignPattern/</url>
      
        <content type="html"><![CDATA[<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>所谓单例，就是整个程序有且仅有一个实例，go语言实现单例模式有懒汉式、饿汉式、双重检查、sync.Once这几种方法</p><h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><p>在需要用到时才创建实例，但不是线程安全的，在多线程（协程）模式时可以被创建多个实例</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name <span class="token builtin">string</span>    Age <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">var</span> p <span class="token operator">*</span>person<span class="token keyword">func</span> <span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>person<span class="token punctuation">{</span>    <span class="token keyword">if</span> p<span class="token operator">==</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        p<span class="token operator">=</span><span class="token function">new</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>        p<span class="token punctuation">.</span>Name<span class="token operator">=</span><span class="token string">"hello"</span>        p<span class="token punctuation">.</span>Age<span class="token operator">=</span><span class="token number">12</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    p<span class="token operator">:=</span> <span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>    f<span class="token operator">:=</span><span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    f<span class="token punctuation">.</span>Name<span class="token operator">=</span><span class="token string">"zhangsan"</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出结果</span>hellozhangsan</code></pre><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p>实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说，占用内存</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name <span class="token builtin">string</span>    Age <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">var</span> p <span class="token operator">*</span>person<span class="token operator">=</span><span class="token operator">&amp;</span>person<span class="token punctuation">{</span>Name<span class="token punctuation">:</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span>Age<span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>person<span class="token punctuation">{</span>    <span class="token keyword">return</span> p<span class="token punctuation">}</span></code></pre><h5 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h5><p>在懒汉式的基础上再进行优化，减少加锁的操作，保证线程安全的同时不影响性能。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name <span class="token builtin">string</span>    Age <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">var</span> lock sync<span class="token punctuation">.</span>Mutex<span class="token keyword">var</span> p <span class="token operator">*</span>person<span class="token keyword">func</span> <span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>person<span class="token punctuation">{</span>    <span class="token keyword">if</span> p<span class="token operator">==</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> p<span class="token operator">==</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>            p<span class="token operator">=</span><span class="token function">new</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">}</span></code></pre><h5 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h5><p>sync.Once可以确保只执行一次，本质上还是双重检查</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name <span class="token builtin">string</span>    Age <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">var</span> p <span class="token operator">*</span>person<span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">GetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>person<span class="token punctuation">{</span>    once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token operator">=</span><span class="token function">new</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>        p<span class="token punctuation">.</span>Name<span class="token operator">=</span><span class="token string">"hello"</span>        p<span class="token punctuation">.</span>Age<span class="token operator">=</span><span class="token number">12</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> p<span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker笔记</title>
      <link href="/2020/08/15/dockerNote/"/>
      <url>/2020/08/15/dockerNote/</url>
      
        <content type="html"><![CDATA[<h4 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h4><p>是一个开源的应用容器引擎，解决了部署环境配置麻烦的问题，可以让部署变得简单高效。</p><h4 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h4><p>有效的将单个操作系统的资源划分到孤立的组中，以便更好的在孤立的组之间平衡有冲突的资源使用需求，这种技术就是容器技术。</p><p>容器话技术不是模拟的一个完整的操作系统，容器内的应用直接运行在宿主机的内核之上，没有自己的内核</p><h4 id="DevOps（开发、运维）"><a href="#DevOps（开发、运维）" class="headerlink" title="DevOps（开发、运维）"></a>DevOps（开发、运维）</h4><h5 id="应用更快速地开发和部署"><a href="#应用更快速地开发和部署" class="headerlink" title="应用更快速地开发和部署"></a>应用更快速地开发和部署</h5><ul><li>传统：帮助文档众多</li><li>docker:打包镜像发布测试，一键运行</li></ul><h5 id="更便捷地升级和扩容"><a href="#更便捷地升级和扩容" class="headerlink" title="更便捷地升级和扩容"></a>更便捷地升级和扩容</h5><p>使用docker后，部署应用就和搭积木一样</p><h5 id="更简单的系统运维"><a href="#更简单的系统运维" class="headerlink" title="更简单的系统运维"></a>更简单的系统运维</h5><p>使用容器之后，开发、测试环境保持高度一致</p><h5 id="更高效的计算机资源利用"><a href="#更高效的计算机资源利用" class="headerlink" title="更高效的计算机资源利用"></a>更高效的计算机资源利用</h5><p>docker是内核级别的虚拟化，可以在一个物理机上运行很多个容器实例</p><h4 id="docker组件"><a href="#docker组件" class="headerlink" title="docker组件"></a>docker组件</h4><h5 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h5><h5 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h5><h5 id="仓库（repository）"><a href="#仓库（repository）" class="headerlink" title="仓库（repository）"></a>仓库（repository）</h5><h4 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h4><p>1.安装yum-utils软件包（提供yum-config-manager 实用程序）并设置稳定的存储库。</p><pre class=" language-shell"><code class="language-shell">sudo yum install -y yum-utilssudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p>2.安装DOCKER引擎</p><pre class=" language-shell"><code class="language-shell">sudo yum install docker-ce docker-ce-cli containerd.io</code></pre><p>3.启动docker</p><pre class=" language-shell"><code class="language-shell">sudo systemctl start docker</code></pre><p>4.运行hello-world 映像来验证是否正确安装了Docker Engine</p><pre class=" language-shell"><code class="language-shell">sudo docker run hello-world</code></pre><h4 id="docker底层原理"><a href="#docker底层原理" class="headerlink" title="docker底层原理"></a>docker底层原理</h4><p>工作原理：docker是一个c/s架构的系统，docker的守护进程运行在主机上，通过socket从客户端访问，dockerServer收到这个命令，就会去执行</p><h4 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h4><h5 id="systemctl-start-docker-启动命令"><a href="#systemctl-start-docker-启动命令" class="headerlink" title="systemctl start docker:启动命令"></a>systemctl start docker:启动命令</h5><p>centos中启动docker</p><pre class=" language-shell"><code class="language-shell">systemctl start docker</code></pre><h5 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h5><ul><li>docker version：查看docker版本信息<pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ /]# docker versionClient: Docker Engine - CommunityVersion:           19.03.13API version:       1.40Go version:        go1.13.15Git commit:        4484c46d9dBuilt:             Wed Sep 16 17:02:36 2020OS/Arch:           linux/amd64Experimental:      falseServer: Docker Engine - CommunityEngine:Version:          19.03.13API version:      1.40 (minimum version 1.12)Go version:       go1.13.15Git commit:       4484c46d9dBuilt:            Wed Sep 16 17:01:11 2020OS/Arch:          linux/amd64Experimental:     falsecontainerd:Version:          1.3.7GitCommit:        8fba4e9a7d01810a393d5d25a3621dc101981175runc:Version:          1.0.0-rc10GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dddocker-init:Version:          0.18.0GitCommit:        fec3683[root@iZbp1hrzkalf9rl3l0lzehZ /]# </code></pre></li><li>docker info:<br>查看docker的系统信息<pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ /]# docker infoClient:Debug Mode: falseServer:Containers: 2Running: 0Paused: 0Stopped: 2Images: 4Server Version: 19.03.13Storage Driver: overlay2Backing Filesystem: xfsSupports d_type: trueNative Overlay Diff: trueLogging Driver: json-fileCgroup Driver: cgroupfsPlugins:Volume: localNetwork: bridge host ipvlan macvlan null overlayLog: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslogSwarm: inactiveRuntimes: runcDefault Runtime: runcInit Binary: docker-initcontainerd version: 8fba4e9a7d01810a393d5d25a3621dc101981175runc version: dc9208a3303feef5b3839f4323d9beb36df0a9ddinit version: fec3683Security Options:seccomp Profile: defaultKernel Version: 4.18.0-193.14.2.el8_2.x86_64Operating System: CentOS Linux 8 (Core)OSType: linuxArchitecture: x86_64CPUs: 1Total Memory: 1.784GiBName: iZbp1hrzkalf9rl3l0lzehZID: AOPS:3LNR:VZUF:J572:WIE5:JGDS:J3EO:327T:H6TM:657C:5UY4:JFHMDocker Root Dir: /var/lib/dockerDebug Mode: falseRegistry: https://index.docker.io/v1/Labels:Experimental: falseInsecure Registries:127.0.0.0/8Live Restore Enabled: false</code></pre></li></ul><p>[root@iZbp1hrzkalf9rl3l0lzehZ /]# </p><pre><code>- docker 命令 --help:查看某命令的用法```shell[root@iZbp1hrzkalf9rl3l0lzehZ /]# docker contianer --helpUsage:    docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions:      --config string      Location of client config files (default "/root/.docker")  -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with "docker context use")  -D, --debug              Enable debug mode  -H, --host list          Daemon socket(s) to connect to  -l, --log-level string   Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info")      --tls                Use TLS; implied by --tlsverify      --tlscacert string   Trust certs signed only by this CA (default "/root/.docker/ca.pem")      --tlscert string     Path to TLS certificate file (default "/root/.docker/cert.pem")      --tlskey string      Path to TLS key file (default "/root/.docker/key.pem")      --tlsverify          Use TLS and verify the remote  -v, --version            Print version information and quitManagement Commands:  builder     Manage builds  config      Manage Docker configs  container   Manage containers  context     Manage contexts  engine      Manage the docker engine  image       Manage images  network     Manage networks  node        Manage Swarm nodes  plugin      Manage plugins  secret      Manage Docker secrets  service     Manage services  stack       Manage Docker stacks  swarm       Manage Swarm  system      Manage Docker  trust       Manage trust on Docker images  volume      Manage volumesCommands:  attach      Attach local standard input, output, and error streams to a running container  build       Build an image from a Dockerfile  commit      Create a new image from a container's changes  cp          Copy files/folders between a container and the local filesystem  create      Create a new container  diff        Inspect changes to files or directories on a container's filesystem  events      Get real time events from the server  exec        Run a command in a running container  export      Export a container's filesystem as a tar archive  history     Show the history of an image  images      List images  import      Import the contents from a tarball to create a filesystem image  info        Display system-wide information  inspect     Return low-level information on Docker objects  kill        Kill one or more running containers  load        Load an image from a tar archive or STDIN  login       Log in to a Docker registry  logout      Log out from a Docker registry  logs        Fetch the logs of a container  pause       Pause all processes within one or more containers  port        List port mappings or a specific mapping for the container  ps          List containers  pull        Pull an image or a repository from a registry  push        Push an image or a repository to a registry  rename      Rename a container  restart     Restart one or more containers  rm          Remove one or more containers  rmi         Remove one or more images  run         Run a command in a new container  save        Save one or more images to a tar archive (streamed to STDOUT by default)  search      Search the Docker Hub for images  start       Start one or more stopped containers  stats       Display a live stream of container(s) resource usage statistics  stop        Stop one or more running containers  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE  top         Display the running processes of a container  unpause     Unpause all processes within one or more containers  update      Update configuration of one or more containers  version     Show the Docker version information  wait        Block until one or more containers stop, then print their exit codesRun 'docker COMMAND --help' for more information on a command.[root@iZbp1hrzkalf9rl3l0lzehZ /]# </code></pre><h5 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h5><ul><li>docker images:查看所有镜像<pre class=" language-shell"><code class="language-shell">[root@izbp1hrzkalf9rl3l0lzehz ~]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              bf756fb1ae65        7 months ago        13.3kBREPOSITORY             #镜像的仓库源TAG                    #镜像的标签IMAGE ID               #镜像的IDCREATED                #镜像的创建时间SIZE                   #镜像的大小</code></pre></li></ul><p>命令可选项<br>-a, –all             #列出所有镜像<br>-q, –quit            #列出镜像的ID</p><pre><code>##### 镜像搜索命令- docker search name：搜索镜像```shell script[root@izbp1hrzkalf9rl3l0lzehz ~]# docker search redisNAME                             DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDredis                            Redis is an open source key-value store that…   8484                [OK]                bitnami/redis                    Bitnami Redis Docker Image                      158                                     [OK]sameersbn/redis                                                                  80                                      [OK]grokzen/redis-cluster            Redis cluster 3.0, 3.2, 4.0, 5.0, 6.0           70                                      rediscommander/redis-commander   Alpine image for redis-commander - Redis man…   46                                      [OK]</code></pre><h5 id="下载命令"><a href="#下载命令" class="headerlink" title="下载命令"></a>下载命令</h5><ul><li>docker pull name:<pre class=" language-shell"><code class="language-shell">[root@izbp1hrzkalf9rl3l0lzehz ~]# docker pull redisUsing default tag: latestlatest: Pulling from library/redisbf5952930446: Pull complete 911b8422b695: Pull complete 093b947e0ade: Pull complete 5b1d5f59e382: Pull complete 7a5f59580c0b: Pull complete f9c63997c980: Pull complete Digest: sha256:09c33840ec47815dc0351f1eca3befe741d7105b3e95bc8fdb9a7e4985b9e1e5Status: Downloaded newer image for redis:latestdocker.io/library/redis:latests</code></pre></li></ul><h5 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h5><ul><li>sudo systemctl restart docker</li></ul><h5 id="docker-rm-ID-name：删除容器"><a href="#docker-rm-ID-name：删除容器" class="headerlink" title="docker rm ID/name：删除容器"></a>docker rm ID/name：删除容器</h5><p>在删除一个docker镜像时，如果镜像已经被作为容器启动过，需要先删除容器才能再删除镜像</p><p>删除容器时用docker rm命令即可</p><pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ usr]# docker rm 1ffbea2d44c31ffbea2d44c3[root@iZbp1hrzkalf9rl3l0lzehZ usr]# docker rm b6bececde071b6bececde071[root@iZbp1hrzkalf9rl3l0lzehZ usr]# </code></pre><h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像:"></a>删除镜像:</h5><p>docker rmi ID/name</p><pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ /]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEmysql               latest              dd7265748b5d        8 days ago          545MBredis               latest              74d107221092        11 days ago         104MBcentos              latest              0d120b6ccaa8        3 months ago        215MBhello-world         latest              bf756fb1ae65        11 months ago       13.3kB[root@iZbp1hrzkalf9rl3l0lzehZ /]# docker rmi mysqlUntagged: mysql:latestUntagged: mysql@sha256:4bb2e81a40e9d0d59bd8e3dc2ba5e1f2197696f6de39a91e90798dd27299b093Deleted: sha256:dd7265748b5dc3211208fb9aa232cef8d3fefd5d9a2a80d87407b8ea649e571cDeleted: sha256:aac9a624212bf416c3b41a62212caf12ed3c578d6b17b0f15be13a7dab56628dDeleted: sha256:1bf3ce09276e9e128108b166121e5d04abd16e7de7473b53b3018c6db0cf23ffDeleted: sha256:24c6444cea460c3cc2f4e0385e3e97819a0672a54a361921f95d4582583abd59Deleted: sha256:77585ebe3eaa035694084b3c5937fe82b8972aae1e6c6070fc4d7bc391d10928Deleted: sha256:1cfd539163ceb17f7bb85a0da968714fe9258b75dbf73f5ad45392a45cfd34b7Deleted: sha256:c37f414ac8d2b5e5d39f159a6dffd30b279c1268f30186cee5da721e451726eaDeleted: sha256:955b3c214bccf3ee2a7930768137fd7ed6a72677334be67a07c78a622abd318aDeleted: sha256:a2e35a0fdb20100365e2fb26c65357fcf926ac7990bf9074a51cbac5a8358d7eDeleted: sha256:8c3a028fc66f360ce6ce6c206786df68fac4c24257474cbe4f67eda0ac21efd6Deleted: sha256:0a6d37fabaceb4faa555e729a7d97cb6ee193cb97789a213907a3d3c156d7e35Deleted: sha256:579519c51de1afe1e29d284b1741af239a307975197cf6ce213a70068d923231[root@iZbp1hrzkalf9rl3l0lzehZ /]# </code></pre><h5 id="新建并启动容器："><a href="#新建并启动容器：" class="headerlink" title="新建并启动容器："></a>新建并启动容器：</h5><ul><li>docker run</li><li>docker run -it –name name：以交互形式启动docker,-i  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；–name  为容器指定一个名称</li><li>docker run -d name:以守护进程的方式运行</li><li>docker start name/ID:启动一个或多个已经被停止的容器</li><li>docker restart name/ID：重启容器</li></ul><h5 id="启动已经存在的容器："><a href="#启动已经存在的容器：" class="headerlink" title="启动已经存在的容器："></a>启动已经存在的容器：</h5><p>docker start name/id</p><h5 id="查看正在运行中的容器："><a href="#查看正在运行中的容器：" class="headerlink" title="查看正在运行中的容器："></a>查看正在运行中的容器：</h5><p>docker ps</p><h5 id="进入已经运行的容器"><a href="#进入已经运行的容器" class="headerlink" title="进入已经运行的容器:"></a>进入已经运行的容器:</h5><ul><li>docker exec -it id/name<pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ ~]# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESbdf56ccd31dd        mycentos            "/bin/bash"         37 minutes ago      Up 37 minutes       8080/tcp            mycentos[root@iZbp1hrzkalf9rl3l0lzehZ ~]# docker exec -it mycentos bin/bash[root@bdf56ccd31dd /]# </code></pre></li></ul><pre><code>- docker attach id/name- 区别：exec进入的是一个新的终端，attach进入的是正在运行的那个终端##### 将容器内文件拷贝到主机docker co id/name:path_docker hosts_path```shelldocker cp mycentos:/usr/temp/main.go /usr/workspace</code></pre><h5 id="查看容器-docker-container"><a href="#查看容器-docker-container" class="headerlink" title="查看容器:docker container"></a>查看容器:docker container</h5><ul><li>docker container ls -a:查看所有的容器<pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ ~]# docker container ls -aCONTAINER ID        IMAGE               COMMAND                   CREATED             STATUS                    PORTS               NAMESa747e52e6987        mycentos            "/bin/bash"               2 days ago          Exited (1) 2 days ago                         quirky_cori6403d52e430f        mycentos            "/bin/bash"               2 days ago          Exited (0) 2 days ago                         jolly_cohenad93a1b2c90d        7bca68e1f58d        "/bin/sh -c 'yum ins…"    2 days ago          Exited (1) 2 days ago                         naughty_kirch5a98e511742b        mynginx:v1.0        "/docker-entrypoint.…"    2 days ago          Exited (0) 2 days ago                         sharp_wilbur4590d95fd096        bc9a0695f571        "/bin/sh -c '[echo \"…"   3 days ago          Exited (127) 3 days ago                       sweet_tharpdf81b88c5b7b        bc9a0695f571        "/bin/sh -c '[echo '…"    3 days ago          Exited (127) 3 days ago                       trusting_meitner786b6e44b074        redis               "docker-entrypoint.s…"    12 days ago         Exited (0) 2 days ago                         cool_pasteurb0ebc81d05e0        redis               "docker-entrypoint.s…"    12 days ago         Exited (2) 12 days ago                        strange_bose[root@iZbp1hrzkalf9rl3l0lzehZ ~]# </code></pre></li></ul><pre><code>##### 关闭容器:docker stop name##### 查看容器日志: - docker logs ID:查看容器日志 ```shell[root@iZbp1hrzkalf9rl3l0lzehZ /]# docker logs 786b6e44b0741:C 29 Nov 2020 09:52:46.604 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo1:C 29 Nov 2020 09:52:46.604 # Redis version=6.0.9, bits=64, commit=00000000, modified=0, pid=1, just started1:C 29 Nov 2020 09:52:46.604 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf                _._                                                             _.-``__ ''-._                                                   _.-``    `.  `_.  ''-._           Redis 6.0.9 (00000000/0) 64 bit  .-`` .-```.  ```\/    _.,_ ''-._                                    (    '      ,       .-`  | `,    )     Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379 |    `-._   `._    /     _.-'    |     PID: 1  `-._    `-._  `-./  _.-'    _.-'                                    |`-._`-._    `-.__.-'    _.-'_.-'|                                   |    `-._`-._        _.-'_.-'    |           http://redis.io          `-._    `-._`-.__.-'_.-'    _.-'                                    |`-._`-._    `-.__.-'    _.-'_.-'|                                   |    `-._`-._        _.-'_.-'    |                                    `-._    `-._`-.__.-'_.-'    _.-'                                         `-._    `-.__.-'    _.-'                                                 `-._        _.-'                                                         `-.__.-'                                               1:M 29 Nov 2020 09:52:46.605 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.1:M 29 Nov 2020 09:52:46.605 # Server initialized1:M 29 Nov 2020 09:52:46.605 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.1:M 29 Nov 2020 09:52:46.605 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to 'madvise' or 'never').1:M 29 Nov 2020 09:52:46.606 * Ready to accept connections</code></pre><ul><li><p>docker logs -f -t –since=”2020-11-28” –tail=100 ID:查看指定时间后的日志，只显示最后10条。-f  跟踪日志输出；-t   显示时间戳；–tail  仅列出最新N条容器日志；</p><pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ /]# docker logs -f -t --since="2020-11-28" --tail==10"docker logs" requires exactly 1 argument.See 'docker logs --help'.Usage:  docker logs [OPTIONS] CONTAINERFetch the logs of a container[root@iZbp1hrzkalf9rl3l0lzehZ /]# docker logs -f -t --since="2020-11-28" --tail==10 786b6e44b0742020-11-29T09:52:46.609392370Z 1:C 29 Nov 2020 09:52:46.604 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo2020-11-29T09:52:46.609415164Z 1:C 29 Nov 2020 09:52:46.604 # Redis version=6.0.9, bits=64, commit=00000000, modified=0, pid=1, just started2020-11-29T09:52:46.609418582Z 1:C 29 Nov 2020 09:52:46.604 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf2020-11-29T09:52:46.609421864Z                 _._                                                  2020-11-29T09:52:46.609424026Z            _.-``__ ''-._                                             2020-11-29T09:52:46.609426163Z       _.-``    `.  `_.  ''-._           Redis 6.0.9 (00000000/0) 64 bit2020-11-29T09:52:46.609428151Z   .-`` .-```.  ```\/    _.,_ ''-._                                   2020-11-29T09:52:46.609430379Z  (    '      ,       .-`  | `,    )     Running in standalone mode2020-11-29T09:52:46.609432423Z  |`-._`-...-` __...-.``-._|'` _.-'|     Port: 63792020-11-29T09:52:46.609434501Z  |    `-._   `._    /     _.-'    |     PID: 12020-11-29T09:52:46.609436493Z   `-._    `-._  `-./  _.-'    _.-'                                   2020-11-29T09:52:46.609445131Z  |`-._`-._    `-.__.-'    _.-'_.-'|                                  2020-11-29T09:52:46.609447287Z  |    `-._`-._        _.-'_.-'    |           http://redis.io        2020-11-29T09:52:46.609449258Z   `-._    `-._`-.__.-'_.-'    _.-'                                   2020-11-29T09:52:46.609451368Z  |`-._`-._    `-.__.-'    _.-'_.-'|                                  2020-11-29T09:52:46.609453373Z  |    `-._`-._        _.-'_.-'    |                                  2020-11-29T09:52:46.609455340Z   `-._    `-._`-.__.-'_.-'    _.-'                                   2020-11-29T09:52:46.609457337Z       `-._    `-.__.-'    _.-'                                       2020-11-29T09:52:46.609459361Z           `-._        _.-'                                           2020-11-29T09:52:46.609461331Z               `-.__.-'                                       </code></pre></li><li><p>docker logs –since 30m ID：查看最近30分钟的日志</p></li></ul><h5 id="docker-kill-name-id-杀掉一个运行中的容器"><a href="#docker-kill-name-id-杀掉一个运行中的容器" class="headerlink" title="docker kill name/id:杀掉一个运行中的容器"></a>docker kill name/id:杀掉一个运行中的容器</h5><pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ ~]# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES9dc94ce74a5a        mycentos            "/bin/bash"         2 minutes ago       Up 2 minutes        8080/tcp            brave_nobel[root@iZbp1hrzkalf9rl3l0lzehZ ~]# docker kill 9dc94ce74a5a9dc94ce74a5a[root@iZbp1hrzkalf9rl3l0lzehZ ~]# </code></pre><h5 id="删除容器：docker-rm-f-name-f表示强制删除"><a href="#删除容器：docker-rm-f-name-f表示强制删除" class="headerlink" title="删除容器：docker rm -f name,-f表示强制删除"></a>删除容器：docker rm -f name,-f表示强制删除</h5><pre class=" language-shell"><code class="language-shell">//删除docker中的所有容器docker rm $(docker container ls)</code></pre><h5 id="列出容器中运行的进程：docker-top-name"><a href="#列出容器中运行的进程：docker-top-name" class="headerlink" title="列出容器中运行的进程：docker top name"></a>列出容器中运行的进程：docker top name</h5><pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ /]# docker top 786b6e44b074UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMDsystemd+            5544                5527                0                   21:30               pts/0               00:00:00            redis-server *:6379[root@iZbp1hrzkalf9rl3l0lzehZ /]# </code></pre><h5 id="提交镜像：docker-commit，会生成一个新的镜像，-a-提交的镜像作者；-c-使用Dockerfile指令来创建镜像；-m-提交时的说明文字；-p-在commit时，将容器暂停"><a href="#提交镜像：docker-commit，会生成一个新的镜像，-a-提交的镜像作者；-c-使用Dockerfile指令来创建镜像；-m-提交时的说明文字；-p-在commit时，将容器暂停" class="headerlink" title="提交镜像：docker commit，会生成一个新的镜像，-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停"></a>提交镜像：docker commit，会生成一个新的镜像，-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停</h5><p>docker commit -a=”xxx” -m=”xxx” ID  name:v1.1</p><pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ ~]# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESbdf56ccd31dd        mycentos            "/bin/bash"         49 seconds ago      Up 48 seconds       8080/tcp            mycentos[root@iZbp1hrzkalf9rl3l0lzehZ ~]# docker commit -a="dyl" mycentos mycentos:v1.0sha256:54b5da54e44c2fe7840e4ad543fccd39128d8400ce3320df421346ad79c4ef73[root@iZbp1hrzkalf9rl3l0lzehZ ~]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEmycentos            v1.0                54b5da54e44c        13 seconds ago      491MBmycentos            latest              2bec99ed389b        3 days ago          491MBmynginx             v1.0                6c9f4177d249        3 days ago          133MBnginx               latest              bc9a0695f571        2 weeks ago         133MBredis               latest              74d107221092        3 weeks ago         104MBcentos              latest              0d120b6ccaa8        4 months ago        215MBhello-world         latest              bf756fb1ae65        11 months ago       13.3kB</code></pre><h5 id="docker-inspect-name-id-查看详细信息"><a href="#docker-inspect-name-id-查看详细信息" class="headerlink" title="docker inspect name/id:查看详细信息"></a>docker inspect name/id:查看详细信息</h5><pre class=" language-shell"><code class="language-shell">[root@iZbp1hrzkalf9rl3l0lzehZ ~]# docker inspect bdf56ccd31dd[    {        "Id": "bdf56ccd31dd2e4a8e135f6899ac0bc15a59ebf41c9f8d6d03a15a6db6a6f77b",        "Created": "2020-12-12T03:26:02.142713872Z",        "Path": "/bin/bash",        "Args": [],        "State": {            "Status": "running",            "Running": true,            "Paused": false,            "Restarting": false,            "OOMKilled": false,            "Dead": false,            "Pid": 26776,            "ExitCode": 0,            "Error": "",            "StartedAt": "2020-12-12T03:26:02.60469655Z",            "FinishedAt": "0001-01-01T00:00:00Z"        },        "Image": "sha256:2bec99ed389b969730f7e385743b62b039b065f9ef987586bbf956b215acaeb8",</code></pre><h5 id="docker容器数据卷"><a href="#docker容器数据卷" class="headerlink" title="docker容器数据卷"></a>docker容器数据卷</h5><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS,可以提供很多有用的特性： - 数据卷可以在容器之间共享和重用 - 对数据卷的修改会立马生效 - 对数据卷的更新，不会影响镜像 - 数据卷默认会一直存在，即使容器被删除。Docker中提供了两种挂载方式，-v和-mount</p><ul><li>创建：docker create volume name</li><li>查看：docker volume ls<pre class=" language-shell"><code class="language-shell">[root@centos ~]# docker volume create mydatamydata[root@centos ~]# docker volume lsDRIVER    VOLUME NAMElocal     mydata</code></pre></li></ul><pre><code>##### docker容器数据卷挂载docker容器数据卷可以实现docker容器和物理主机之间的数据/文件共享- 命令挂载方式1：docker run -it -v hosts_path:container_path```shell[root@centos ~]# docker run --name centos -v /my:/docker -it centos:8.1.1911 /bin/bash[root@d54473f39331 /]# //其中冒号后面必须要跟/docker，直接写镜像中的路径的话，会报错//当主机文件或文件夹不存在时会自动创建，主机目录中的文件或者文件夹是手动创建的话挂载也会报错</code></pre><ul><li>命令挂载方式2：docker run –name xxxx -p 8888:8888 –mount   <pre><code>    type:volume,source=/src/xxx,target=/xxx /my:/docker -it imagename /bin/bash </code></pre></li></ul><h5 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h5><p>dockerfile是用来构建docker镜像的文件，文件中包含了一些配置命令</p><ul><li><p>FROM命令：指定基础镜像</p><pre class=" language-shell"><code class="language-shell">FROM centos</code></pre></li><li><p>RUN命令：指定要运行的命令，后面可接shell命令，也可以接exec格式参数</p><pre class=" language-shell"><code class="language-shell">RUN ["./test.php", "dev", "offline"] //等价于 RUN ./test.php dev offline</code></pre></li><li><p>copy指令：将主机文件复制到容器中目录下</p><pre class=" language-shell"><code class="language-shell">COPY host_psth docker_path</code></pre></li><li><p>ADD指令：将主机文件复制到容器中，并且会自动解压</p></li><li><p>CMD指令：运行命令，CMD在docker run时执行，而RUN命令在docker build时执行</p></li><li><p>ENTRYPOINT：docker run时运行命令，但是可以添加参数命令不会被覆盖</p></li><li><p>ENV：环境变量</p></li><li><p>ARG：环境变量，docker build过程中有效，但是建好的容器中不存在</p></li><li><p>VOLUME：指定挂载点</p></li><li><p>WORKDIR：指定工作目录</p></li></ul><h5 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h5><ul><li>docker build -t name:tag -f file_path .</li></ul><h5 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h5><p>在docker中，容器之间需要网络连接，这就需要用到docker网络技术了。<br><img src="/2020/08/15/dockerNote/dockernetwork.png" alt=""></p><h5 id="docker容器连接"><a href="#docker容器连接" class="headerlink" title="docker容器连接"></a>docker容器连接</h5><p>docker中想要不通过docker网络分配的IP进行通讯，可以使用–link参数在启动容器的时候连接到已经存在的容器，这样就可以直接使用容器名或者容器ID进行网络连接</p><pre class=" language-shell"><code class="language-shell">docker run -it --name name --link container_name image_name</code></pre><h5 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h5><p>一般不建议使用docker的桥接模式了，推荐使用自建网络</p><ul><li>docker network create –driver bridge –subnet ip –gateway gateway_ip network_name<pre class=" language-shell"><code class="language-shell">[root@centos /]# docker network create --driver bridge --subnet 192.168.10.0/24 --gateway 192.168.10.1 hello3f77fe76ad2a22f0df94be1134080ad8d39863428fc12bfe3e2a3e692547381c[root@centos /]# </code></pre></li></ul><pre><code>- docker network connect network container：将容器连通到docker网络中。 建立好自定义网络后，在启动容器时只需要指定网络为自定义的，就可以使用自定义网络了</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言</title>
      <link href="/2020/08/14/go-web/"/>
      <url>/2020/08/14/go-web/</url>
      
        <content type="html"><![CDATA[<h4 id="简易服务"><a href="#简易服务" class="headerlink" title="简易服务"></a>简易服务</h4><p>net/http包是go语言自带的一个包，使用这个包可以极为方便地搭建一个web后台,也可以使用这个包来发送各种请求，编写爬虫。</p><p>后台想要接收和识别浏览器发过来的http请求，需要实现一个函数，这个函数的参数为(w http.ResponseWriter,r *http.Request)，形参名可变</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>handler<span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:8000"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">handler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span>r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>处理http请求的时候，也可以使用http.Handle()函数，使用该函数需要自己先实现一个Handle接口,该接口仅有一个ServeHTTP(ResponseWriter, *Request)方法，所以定义一个字段个数为0的结构体，实现该方法即可</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span><span class="token function">new</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//http.HandleFunc("/",handler)</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:8000"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> handle <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span><span class="token punctuation">(</span>h <span class="token operator">*</span>handle<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span>r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token string">"hello world!->handel"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>go语言自带的有text/template和html/template两个包，都可以解析HTML文档，两个模板引擎用法相似</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"html/template"</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>handler<span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:8001"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">handler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span>r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span>    t<span class="token punctuation">,</span>err<span class="token operator">:=</span>template<span class="token punctuation">.</span><span class="token function">ParseFiles</span><span class="token punctuation">(</span><span class="token string">"main/404.html"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    t<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>处理静态资源时，使用http.StripPrefix()函数，会自动匹配某一前缀的请求，并将其替换成第二个参数(handle类型)中的物理路径</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"html/template"</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/static/"</span><span class="token punctuation">,</span>http<span class="token punctuation">.</span><span class="token function">StripPrefix</span><span class="token punctuation">(</span><span class="token string">"/static/"</span><span class="token punctuation">,</span>http<span class="token punctuation">.</span><span class="token function">FileServer</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">Dir</span><span class="token punctuation">(</span><span class="token string">"static/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>handler<span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:8001"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">handler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span>r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span>    t<span class="token punctuation">,</span>err<span class="token operator">:=</span>template<span class="token punctuation">.</span><span class="token function">ParseFiles</span><span class="token punctuation">(</span><span class="token string">"main/404.html"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    t<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> go语言 </tag>
            
            <tag> net/http包 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis笔记</title>
      <link href="/2020/08/10/redisNote/"/>
      <url>/2020/08/10/redisNote/</url>
      
        <content type="html"><![CDATA[<h4 id="NoSQL概念"><a href="#NoSQL概念" class="headerlink" title="NoSQL概念"></a>NoSQL概念</h4><ul><li>NoSQL：not only SQL，泛指非关系型数据库</li><li>常见分类：键值对存储数据库、列存储数据库、文档存储数据库、图形数据库</li><li>优点：1.方便扩展（数据之间没有关系，好扩展） 2.大数据量高性能 3.数据类型多样（不需要设计数据库）</li><li>大数据时代3V和3高：海量（Volume）、多样（Variety）、实时（Velocity），高并发、高可用、高可扩</li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。Redis是单线程的。</p><h4 id="Redis操作"><a href="#Redis操作" class="headerlink" title="Redis操作"></a>Redis操作</h4><p>常见命令</p><h5 id="清空（慎用）"><a href="#清空（慎用）" class="headerlink" title="清空（慎用）"></a>清空（慎用）</h5><ul><li>flushdb：  清空当前数据库</li><li>flushall:  清空全部数据库</li></ul><h5 id="Redis-key类型"><a href="#Redis-key类型" class="headerlink" title="Redis-key类型"></a>Redis-key类型</h5><ul><li>select db：选择数据库</li><li>keys *：查看所有的key（数据量小时使用，数据量大了会大量占用内存，导致机器瘫痪）</li><li>info、info Keyspace：查看</li><li>set key value:设置键值对,如果键存在就是修改，不存在就是添加</li><li>exists key:查看是否存在key</li><li>move key db：将键值对移动到另一个数据库中去</li><li>get key：获取key</li><li>mset k1 v1 k2 v2…：同时设置多个键值对</li><li>mget k1 k2 …：同时获取多个值</li><li>setex key time value：为指定的 key 设置值及其过期时间</li><li>del key：删除键值对</li><li>expire key time:设置过期时间</li><li>ttl key：查看还有多久过期</li><li>type key：查看类型</li></ul><h5 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h5><ul><li>incr key:key对应的整数值加1</li><li>incrby key num:key对应的整数值增加num</li><li>decr key：key对应的整数值减1</li><li>decrby key num:key对应的整数值增减num</li><li>getrange key start end:从start到end范围截取key对应的字符串值，是一个闭区间<pre class=" language-sql"><code class="language-sql">获取全部内容getrange <span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span></code></pre></li><li>setrange key start end value:将start到end区间替换为value</li><li>setnx key value:在指定的 key 不存在时，为 key 设置指定的值,如果存在就会设置失败</li><li>msetnx k1 v1 k2 v2…:批量设置，要么一起成功，要么一起失败</li></ul><pre class=" language-sql"><code class="language-sql">设置<span class="token keyword">user</span>:<span class="token number">1</span>对象<span class="token punctuation">,</span>用json方式<span class="token keyword">set</span> <span class="token keyword">user</span>:<span class="token number">1</span>{name:xx<span class="token punctuation">,</span>age:<span class="token number">1</span>}<span class="token keyword">key</span>的设计:<span class="token keyword">user</span>:{id}:{filed}mset <span class="token keyword">user</span>:<span class="token number">1</span> name xx <span class="token keyword">user</span>:<span class="token number">1</span> age <span class="token number">1</span></code></pre><h5 id="list：可作为栈、队列、阻塞队列使用"><a href="#list：可作为栈、队列、阻塞队列使用" class="headerlink" title="list：可作为栈、队列、阻塞队列使用"></a>list：可作为栈、队列、阻塞队列使用</h5><ul><li>lpush list value:在list左边添加</li><li>rpush list value:在list右边添加</li><li>lpop list:弹出最左边元素</li><li>rpop list:弹出最右边元素</li><li>lrange list start end:截取start到end的元素</li><li>lindex list index:通过下标获取值</li><li>llen list：获取list的大小</li><li>lpoprpush list1 list2:组合命令，将list1中的最左元素添加到list2的最右边</li><li>lset list index value:将第index个元素替换成value</li></ul><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><ul><li>sadd set value:在set中添加一个元素</li><li>scard set:获取set中元素的个数</li><li>sdiff set1 set2：返回集合之间的差集</li><li>sinter set1 set2:返回集合之间的交集</li><li>sunion set1 set2:返回集合之间的并集</li><li>smembers set:返回set中的所有成员</li><li>spop set:随机删除并返回一个元素</li><li>sismember set value:判断value是否是set中的元素</li><li>smove set1 set2 value：将一个指定的set1中的值移动大另一个set2中</li></ul><h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><ul><li>hset hash field value:给hash设置字段</li><li>hget hash field:获取字段</li><li>hmset hash field1 value1 [……]:批量获取字段</li><li>hgetall hash:获取全部数据</li><li>hdel hash field：删除hash中的字段</li><li>hlen hash:获取hash字段数量</li><li>hexists hash filed：查看字段是否存在</li><li>hkeys hash:获取所有key</li><li>hvals hash:获取所有值</li><li>hincrby hash field number:field增加number</li><li>hsetnx hash field value:如果field不存在，则可以设值</li></ul><h5 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset(有序集合)"></a>zset(有序集合)</h5><ul><li>zset key1 score value:</li><li>zadd set key value:添加元素</li><li>zrange set start end:从start到end截取set元素</li><li>zrangebyscore set -inf +inf:从小到大排序</li><li>zrem set field:删除元素</li><li>zcard set：获取有序集合中的个数</li><li>zcount set start end:获取start到end之间的元素个数</li></ul><h5 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial 地理位置"></a>geospatial 地理位置</h5><p>应用：定位信息存储、附近的人计算、打车距离计算,底层维护的是一个zset，可以是有zset的操作</p><ul><li><p>geoadd key  longitude latitude member:用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</p><pre class=" language-sql"><code class="language-sql">geoadd china:city <span class="token number">116.40</span> <span class="token number">39.90</span> beijing</code></pre></li><li><p>geodist key member1 member2 [m米/km千米/ft英尺/mi英里]:按照给定的单位返回两个定位之间的距离</p><pre class=" language-sql"><code class="language-sql">geodist china:city beijing shanghai km </code></pre></li><li><p>georadius key longtitude latitude radius m/km/ft/mi:以给定的经纬度为中心，找出某一半径内的元素</p><pre class=" language-sql"><code class="language-sql">georadius china:city <span class="token number">110</span> <span class="token number">30</span> <span class="token number">1000</span> km</code></pre></li><li><p>geopos key member:获取member的经纬度</p><pre class=" language-sql"><code class="language-sql">geopos china:city beijing</code></pre></li><li><p>zrem key member：移除member</p></li><li><p>zrange key start end：截取从start到end的元素</p></li></ul><h5 id="hyperloglog"><a href="#hyperloglog" class="headerlink" title="hyperloglog"></a>hyperloglog</h5><p>用于基数统计相关，基数是指多个数据集中不重复的元素，hyperloglog存在一定的误差,但是占用的内存是固定的64k<br>网站访问人数统计等可以用次结构来做</p><ul><li>pfadd key element:添加元素</li><li>pfcount key:返回元素个数</li><li>pfmerge key1 ke2 k3:将k2和k3合并为key1</li></ul><h5 id="bitmap：位图"><a href="#bitmap：位图" class="headerlink" title="bitmap：位图"></a>bitmap：位图</h5><ul><li>setbit key offset value：把key的offset位设为value,value取值为0或1</li><li>getbit key offset:获取第offset位的值</li><li>bitcount key [start end]：获取从start到end范围内的1的个数</li></ul><h4 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h4><p>Redis的事务跟mysql登封关系型数据库是不同的，Redis单条命令是原子性的，要么成功要么失败，而Redis的事务不保证原子性。</p><p>Redis事务的本质就是一组命令的集合，将所有命令放入队列暂不执行，输入事务执行命令后才会开始执行，然后依次执行</p><p>Redis事务的顺序：</p><ol><li>开启事务</li><li>命令入队</li><li>执行事务</li></ol><pre class=" language-sql"><code class="language-sql">开启事务<span class="token operator">-</span><span class="token operator">></span>  multi   <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">set</span> k1 v1<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">set</span> k2 v2<span class="token operator">-</span><span class="token operator">></span>  get k1<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">set</span> k3 v3执行事务<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">exec</span>取消事务<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">discard</span></code></pre><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p><p>Redis的乐观锁实现采用的是watch命令</p><ul><li>watch key:监视key，如果key被改变则事务中断</li><li>unwatch key：取消监视</li></ul><p>如果事务失败，先解锁，然后重新加锁，再次进行事务操作</p><p><img src="/2020/08/10/redisNote/img/OptimisticLocking.png" alt=""></p><h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><h5 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h5><p>RDB：保存redis数据的快照，Redis会单独创建(fork)一个子进程来进行持久化,会先将数据写入到一个临时文件中(dump.rdb)，持久化进程结束后，再替换以前持久化的文件。恢复时，Redis会直接将快照读入内存。</p><p>优点:</p><ol><li>一般时候对性能影响较小</li><li>非常适合做冷备</li><li>数据恢复快</li></ol><p>缺点:</p><ol><li>如果数据量大时候，内存占用较高</li><li>可能会丢失数据</li></ol><ol><li>save触发方式：该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止<br><img src="/2020/08/10/redisNote/img/rdb.jpg" alt=""></li><li>bgsave触发方式：执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求<br><img src="/2020/08/10/redisNote/img/rdb2.jpg" alt=""></li><li>自动触发：在配置文件中设置触发规则。执行flushall或者退出Redis时，也会自动触发RDB</li></ol><p>只要将RDB文件放在Redis启动目录，Redis启动时会自动恢复</p><h5 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h5><p>以日志的形式来记录每个写操作，将所有的指令记录下来，只许追加文件不允许写，Redis启动之后会读取该文件(appendonly.aof)重新构建。</p><p>与RDB不同，AOF需要手动开启。</p><p>AOF机制的优点:</p><ol><li>每一次修改都同步，数据完整性更高</li><li>每秒同步一次，则可能会丢失1秒的数据</li><li>从不同步，效率最高</li></ol><p>AOF的缺点：</p><ol><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</li><li>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</li><li>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</li><li>AOF文件错误，则Redis无法启动</li></ol><h4 id="Redis基准测试"><a href="#Redis基准测试" class="headerlink" title="Redis基准测试"></a>Redis基准测试</h4><p>redis-benchmark [option] [option value]</p><pre class=" language-sql"><code class="language-sql">同时执行 <span class="token number">10000</span> 个请求来检测性能redis<span class="token operator">-</span>benchmark <span class="token operator">-</span>n <span class="token number">10000</span> <span class="token operator">-</span>q</code></pre><h4 id="Redis订阅发布"><a href="#Redis订阅发布" class="headerlink" title="Redis订阅发布"></a>Redis订阅发布</h4><p>Redis订阅发布是一种消息通信模式：发送者(pub)发送消息,订阅者(sub)接收消息，Redis可以订阅任意数量的频道</p><p>订阅一个频道后，Redis-server里维护了一个字典，这个字典的键就是一个个频道，字典的值是一个链表，链表中包含了所有订阅这个频道的客户端。</p><p>订阅消息发布：<br><img src="/2020/08/10/redisNote/img/Redispubsub.png" alt=""></p><p>操作命令：</p><ul><li>subscribe name:订阅一个频道</li><li>publish name value:发布消息到频道</li></ul><h4 id="Redis集群部署"><a href="#Redis集群部署" class="headerlink" title="Redis集群部署"></a>Redis集群部署</h4><p>Redis在默认的情况下，每台Redis服务器都是一个主节点。一般使用时最少是一主二从的结构。</p><p>主节点是用来进行写操作的，从节点是用来进行读操作的。</p><ul><li>slaveof host port：将本机配置为某Redis服务器的从节点（重启之后会自动变回主节点）。</li></ul><p>在主节点断开后，从节点依旧是连接在主节点，但是无法进行写操作。主节点重新连接，从节点可以获取主节点的写信息。</p><p>主从复制的原理：salve节点启动连接到master节点后，会发送sync同步命令。master节点收到命令后，启动后台存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕后，master将传送整个数据文件到slave，并完成一次完全同步</p><p>全量复制：salve接收到文件之后，将其存盘并加载进内存<br>增量复制：master继续将行接收到的命令依次传给slave完成同步</p><p>只要重新连接master，一次完全同步(全量复制)将自动执行</p><p>主从复制的作用：</p><ol><li>热备份</li><li>故障恢复</li><li>负载均衡</li><li>高可用(集群)基石</li></ol><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>服务器宕机之后，手动配置的话费时费力，哨兵(sentinel)模式会自动从从节点中选举出一台作为主节点，如果原主节点恢复了，将会成为一个从节点</p><p>哨兵是一个独立的进程，会独立运行，哨兵通过发送命令，等待Redis服务器响应，从而监控多个Redis实例。多个哨兵之间也会相互监控。<br>服务器宕机后，只被一个哨兵发现时，会被该哨兵主观认为是不可用的，称为主观下线。多个哨兵检测到主节点不可用并且达到一定数量，哨兵会进行一次投票，投票由一个哨兵发起，进行failover(故障转移)操作。切换成功后，会通过发布订阅模式，让各个哨兵把自己监控的从节点实现切换为主节点，这个过程称为客观下线。</p><h4 id="Redis缓存穿透"><a href="#Redis缓存穿透" class="headerlink" title="Redis缓存穿透"></a>Redis缓存穿透</h4><p>缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源</p><p>例子：用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透</p><p>解决方案：</p><ol><li>布隆过滤器：</li><li>缓存空对象：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；带来的问题：如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ol><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>概念：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p><p>解决方案：</p><ol><li>Redis高可用</li><li>流量降级</li><li>数据预热</li></ol><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>概念：指一个key非常热点，扛着很大的并发量，当key失效的瞬间，持续的大并发就会穿破缓存层，直接请求数据库，数据库压力暴增。</p><p>解决方案：</p><ol><li>设置热点永不过期</li><li>加互斥锁</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2020/07/23/redblacktree/"/>
      <url>/2020/07/23/redblacktree/</url>
      
        <content type="html"><![CDATA[<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>定义：红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ol><li>每个节点要么是黑色，要么是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。</li><li>每个红色结点的两个子结点一定都是黑色（红黑树不会出现相邻的红色节点）</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li></ol><p>红黑树是一种黑色完美平衡的二叉树（不是完美平衡的二叉树）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 查找 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2020/07/16/tree/"/>
      <url>/2020/07/16/tree/</url>
      
        <content type="html"><![CDATA[<h4 id="树的介绍"><a href="#树的介绍" class="headerlink" title="树的介绍"></a>树的介绍</h4><p>树是节点按分支关系组成的一种结构，具有插入和删除效率高的优点，但是查找效率较低，二叉树不是树的特例（即二叉树不是树）</p><h4 id="常见二叉树分类"><a href="#常见二叉树分类" class="headerlink" title="常见二叉树分类"></a>常见二叉树分类</h4><ul><li>普通二叉树</li><li>完全二叉树</li><li>满二叉树</li><li>线索二叉树</li><li>哈夫曼树</li><li>二叉排序树</li><li>平衡二叉树（AVL）</li><li>红黑树</li></ul><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉树的存储结构可以用顺序存储和链式存储来存储。二叉树的顺序存储结构由一组连续的存储单元依次从上到下，从左到右存储完全二叉树的结点元素。对于一般二叉树，应将其与完全二叉树对应，然后给每个结点从1到i编上号，依次存储在大小为i-1的数组中。这种方法只适用于完全二叉树，对非完全二叉树会浪费较多空间，最坏情况一个深度为k的二叉树只有k个结点，却需要长度为2的k次方减一长度的一位数组。事实上，二叉树一般使用链式存储结构，由二叉树的定义可知，二叉树的结点由一个数据元素和分别指向其左右孩子的指针构成，即二叉树的链表结点中包含3个域，这种结点结构的二叉树存储结构称之为二叉链表。</p><h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><p><img src="/2020/07/16/tree/img/BTree.jpg" alt=""></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>定义：若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><h5 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h5><p><img src="/2020/07/16/tree/img/CompleteBinaryTree.jpg" alt=""></p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>定义：一棵二叉树的结点要么是叶子结点，要么它有两个子结点（如果一个二叉树的层数为K，且结点总数是(2^k) -1，则它就是满二叉树。）</p><h5 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h5><p><img src="/2020/07/16/tree/img/FullBinaryTree.jpg" alt=""></p><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>定义：对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树</p><h5 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h5><p><img src="/2020/07/16/tree/img/ThreadedBinaryTree.jpg" alt=""></p><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树（Huffman Tree）是在叶子结点和权重确定的情况下，带权路径长度最小的二叉树，也被称为最优二叉树。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p> <img src="/2020/07/16/tree/img/HuffmanTree.jpg" alt=""><br> <img src="/2020/07/16/tree/img/HuffmanTree2.jpg" alt=""></p><h4 id="二叉排序树（二叉搜索树、二叉查找树）"><a href="#二叉排序树（二叉搜索树、二叉查找树）" class="headerlink" title="二叉排序树（二叉搜索树、二叉查找树）"></a>二叉排序树（二叉搜索树、二叉查找树）</h4><p>定义：根节点的值大于其左子树中任意一个节点的值，小于其右节点中任意一节点的值，这一规则适用于二叉查找树中的每一个节点。</p><h5 id="图示-4"><a href="#图示-4" class="headerlink" title="图示"></a>图示</h5><p><img src="/2020/07/16/tree/img/BinarySortTree.jpg" alt=""></p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>定义:可以是空树。假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过</p><h5 id="图示-5"><a href="#图示-5" class="headerlink" title="图示"></a>图示</h5><p><img src="/2020/07/16/tree/img/BalanceTree.jpg" alt=""></p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>定义：红黑树就是一种平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。除了符合二叉查找树的特性之外，还具体下列的特性：</p><ol><li><p>节点是红色或者黑色</p></li><li><p>根节点是黑色</p></li><li><p>每个叶子的节点都是黑色的空节点（NULL）</p></li><li><p>每个红色节点的两个子节点都是黑色的。</p></li><li><p>从任意节点到其每个叶子的所有路径都包含相同的黑色节点。</p></li></ol><h5 id="图示-6"><a href="#图示-6" class="headerlink" title="图示"></a>图示</h5><p><img src="/2020/07/16/tree/img/RedBlackTree.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2020/07/15/sort/"/>
      <url>/2020/07/15/sort/</url>
      
        <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思想：将数组分为已排序和未排序两部分，每次从未排序部分选出最小的数放入已排序部分</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/2020/07/15/sort/xuanze.gif" alt=""></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>记上待排序部分的第一个数字的索引min</li><li>对待排序部分遍历，如果有比第nums[min]小的，将索引值赋min</li><li>将待排序部分首元素与nums[min]交换</li><li>重复3和4</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>cur <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> cur<span class="token operator">>=</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> min <span class="token builtin">int</span><span class="token operator">=</span>cur    <span class="token keyword">for</span> i <span class="token operator">:=</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span>  <span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">{</span>            min<span class="token operator">=</span>i        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span>    cur<span class="token operator">++</span>    <span class="token function">SelectSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>cur<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序</p><h4 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h4><p><img src="/2020/07/15/sort/kuaisu.png" alt=""></p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li>选择一个基准值，为了方便选择待排序部分首元素,用l表示左指针，r表示右指针</li><li>遍历待排序部分，对右指针向前移动，直到有小于基准值的元素出现，将r所指的值赋予l所指的元素,l小于r</li><li>对左指针进行移动，直到有大于基准值的元素出现，l所指的值赋予r所指的元素,l小于r</li><li>当l和r相等时，就将基准值赋予该元素，基准值将数组分为左右两部分，对这两部分进行2到4的操作</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>l <span class="token builtin">int</span><span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//对左右下标进行比较，l小于r时就返回，防止程序出错</span>    <span class="token keyword">if</span> l<span class="token operator">></span>r<span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//pviot为基准值</span>    <span class="token keyword">var</span> pviot <span class="token builtin">int</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">//保存函数中传入的l原值</span>    <span class="token keyword">var</span> left <span class="token builtin">int</span><span class="token operator">=</span>l    <span class="token comment" spellcheck="true">//保存函数中传入的r原值</span>    <span class="token keyword">var</span> right <span class="token builtin">int</span><span class="token operator">=</span>r    <span class="token comment" spellcheck="true">//循环排序</span>    <span class="token keyword">for</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//基准值选了待排序部分最左边，所以从r开始</span>        <span class="token comment" spellcheck="true">//如果右边得值大于基准值，不用与左边交换，只需r减小，直到右边的值小于基准值</span>        <span class="token keyword">for</span> pviot<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">{</span>            r<span class="token operator">--</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//此时右边所指的数小于左边，需要将右边得值赋给左边</span>        <span class="token keyword">if</span> r<span class="token operator">></span>l<span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> pviot<span class="token operator">>=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">{</span>            l<span class="token operator">++</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> r<span class="token operator">></span>l<span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//此时l和r指向同一个数字，把基准值放在此处</span>    nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>pviot    <span class="token comment" spellcheck="true">//对基准值左边进行快速排序</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>l<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//对基准值右边进行快速排序</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想：归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法的一个非常典型的应用，且各层分治递归可以同时进行。</p><ul><li>分解（Divide）： 将n个元素分成个含n/2个元素的子序列。</li><li>解决（Conquer）：用合并排序法对两个子序列递归的排序。</li><li>合并（Combine）：合并两个已排序的子序列已得到排序结果。</li></ul><h4 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h4><p><img src="/2020/07/15/sort/guibing.png" alt=""></p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li>对待排序部分分为左右两部分</li><li>对左边部分递归进行归并排序</li><li>对右边部分递归进行归并排序</li><li>对这两部分进行合并</li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>l <span class="token builtin">int</span><span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> l<span class="token operator">>=</span>r<span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> middle <span class="token builtin">int</span><span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>    <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>middle<span class="token punctuation">)</span>    <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span>    <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>middle<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">merge</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>l <span class="token builtin">int</span><span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">,</span>middle <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> temp <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span><span class="token operator">=</span><span class="token number">0</span>    <span class="token keyword">var</span> j <span class="token builtin">int</span><span class="token operator">=</span>l    <span class="token keyword">var</span> k <span class="token builtin">int</span><span class="token operator">=</span>middle<span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">for</span> j<span class="token operator">&lt;=</span>middle<span class="token operator">&amp;&amp;</span>k<span class="token operator">&lt;=</span>r<span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j<span class="token operator">++</span>            i<span class="token operator">++</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>            k<span class="token operator">++</span>            i<span class="token operator">++</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> j<span class="token operator">&lt;=</span>middle<span class="token punctuation">{</span>        temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        j<span class="token operator">++</span>        i<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> k<span class="token operator">&lt;=</span>r<span class="token punctuation">{</span>        temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        k<span class="token operator">++</span>        i<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>l<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>思想：工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序，有可能再使用别的排序算法或是以递归方式继续使用桶排序</p><h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里面去；</li><li>对每个不是空的桶进行排序。</li><li>从不是空的桶里面把排序好的数据进行拼接；</li></ul><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>思想：它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h4><ol><li>将第一个元素视为已经排序</li><li>从第一个元素开始依次向后取出元素，与它前面已经排序的序列比较，将它插入到合适的位置</li></ol><h4 id="图解-3"><a href="#图解-3" class="headerlink" title="图解"></a>图解</h4><p><img src="/2020/07/15/sort/insertSort.jpg" alt=""></p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>cur <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> cur<span class="token operator">>=</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> temp <span class="token builtin">int</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span>    <span class="token keyword">for</span> i<span class="token operator">=</span>cur<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span>temp <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp            <span class="token keyword">break</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">InsertSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="希尔排序（shell-sort）"><a href="#希尔排序（shell-sort）" class="headerlink" title="希尔排序（shell sort）"></a>希尔排序（shell sort）</h3><p>思想:希尔排序算是对简单插入排序的一种改进，属于一种增量式的排序算法，通过对数组”分组微调”,使大部分元素有序，减少插入排序的工作量</p><h4 id="图解-4"><a href="#图解-4" class="headerlink" title="图解"></a>图解</h4><p><img src="/2020/07/15/sort/shellsort.png" alt=""></p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> n <span class="token builtin">int</span><span class="token operator">=</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>    <span class="token keyword">for</span> n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span>n<span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>            <span class="token keyword">var</span> temp <span class="token builtin">int</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">var</span> tag <span class="token builtin">int</span><span class="token operator">=</span>i<span class="token operator">-</span>n            <span class="token keyword">for</span> tag<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token operator">></span>temp<span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>tag<span class="token operator">+</span>n<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>tag<span class="token punctuation">]</span>                tag<span class="token operator">=</span>tag<span class="token operator">-</span>n            <span class="token punctuation">}</span>            nums<span class="token punctuation">[</span>tag<span class="token operator">+</span>n<span class="token punctuation">]</span><span class="token operator">=</span>temp        <span class="token punctuation">}</span>        n<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/04/hello-world/"/>
      <url>/2020/07/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
