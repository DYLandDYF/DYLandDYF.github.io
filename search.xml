<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis笔记</title>
      <link href="/2020/08/10/redisNote/"/>
      <url>/2020/08/10/redisNote/</url>
      
        <content type="html"><![CDATA[<h4 id="NoSQL概念"><a href="#NoSQL概念" class="headerlink" title="NoSQL概念"></a>NoSQL概念</h4><ul><li>NoSQL：not only SQL，泛指非关系型数据库</li><li>常见分类：键值对存储数据库、列存储数据库、文档存储数据库、图形数据库</li><li>优点：1.方便扩展（数据之间没有关系，好扩展） 2.大数据量高性能 3.数据类型多样（不需要设计数据库）</li><li>大数据时代3V和3高：海量（Volume）、多样（Variety）、实时（Velocity），高并发、高可用、高可扩</li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。Redis是单线程的。</p><h4 id="Redis操作"><a href="#Redis操作" class="headerlink" title="Redis操作"></a>Redis操作</h4><p>常见命令</p><h5 id="清空（慎用）"><a href="#清空（慎用）" class="headerlink" title="清空（慎用）"></a>清空（慎用）</h5><ul><li>flushdb：  清空当前数据库</li><li>flushall:  清空全部数据库</li></ul><h5 id="Redis-key类型"><a href="#Redis-key类型" class="headerlink" title="Redis-key类型"></a>Redis-key类型</h5><ul><li>select db：选择数据库</li><li>keys *：查看所有的key（数据量小时使用，数据量大了会大量占用内存，导致机器瘫痪）</li><li>info、info Keyspace：查看</li><li>set key value:设置键值对,如果键存在就是修改，不存在就是添加</li><li>exists key:查看是否存在key</li><li>move key db：将键值对移动到另一个数据库中去</li><li>get key：获取key</li><li>mset k1 v1 k2 v2…：同时设置多个键值对</li><li>mget k1 k2 …：同时获取多个值</li><li>setex key time value：为指定的 key 设置值及其过期时间</li><li>del key：删除键值对</li><li>expire key time:设置过期时间</li><li>ttl key：查看还有多久过期</li><li>type key：查看类型</li></ul><h5 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h5><ul><li>incr key:key对应的整数值加1</li><li>incrby key num:key对应的整数值增加num</li><li>decr key：key对应的整数值减1</li><li>decrby key num:key对应的整数值增减num</li><li>getrange key start end:从start到end范围截取key对应的字符串值，是一个闭区间<pre class=" language-sql"><code class="language-sql">获取全部内容getrange <span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span></code></pre></li><li>setrange key start end value:将start到end区间替换为value</li><li>setnx key value:在指定的 key 不存在时，为 key 设置指定的值,如果存在就会设置失败</li><li>msetnx k1 v1 k2 v2…:批量设置，要么一起成功，要么一起失败</li></ul><pre class=" language-sql"><code class="language-sql">设置<span class="token keyword">user</span>:<span class="token number">1</span>对象<span class="token punctuation">,</span>用json方式<span class="token keyword">set</span> <span class="token keyword">user</span>:<span class="token number">1</span>{name:xx<span class="token punctuation">,</span>age:<span class="token number">1</span>}<span class="token keyword">key</span>的设计:<span class="token keyword">user</span>:{id}:{filed}mset <span class="token keyword">user</span>:<span class="token number">1</span> name xx <span class="token keyword">user</span>:<span class="token number">1</span> age <span class="token number">1</span></code></pre><h5 id="list：可作为栈、队列、阻塞队列使用"><a href="#list：可作为栈、队列、阻塞队列使用" class="headerlink" title="list：可作为栈、队列、阻塞队列使用"></a>list：可作为栈、队列、阻塞队列使用</h5><ul><li>lpush list value:在list左边添加</li><li>rpush list value:在list右边添加</li><li>lpop list:弹出最左边元素</li><li>rpop list:弹出最右边元素</li><li>lrange list start end:截取start到end的元素</li><li>lindex list index:通过下标获取值</li><li>llen list：获取list的大小</li><li>lpoprpush list1 list2:组合命令，将list1中的最左元素添加到list2的最右边</li><li>lset list index value:将第index个元素替换成value</li></ul><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><ul><li>sadd set value:在set中添加一个元素</li><li>scard set:获取set中元素的个数</li><li>sdiff set1 set2：返回集合之间的差集</li><li>sinter set1 set2:返回集合之间的交集</li><li>sunion set1 set2:返回集合之间的并集</li><li>smembers set:返回set中的所有成员</li><li>spop set:随机删除并返回一个元素</li><li>sismember set value:判断value是否是set中的元素</li><li>smove set1 set2 value：将一个指定的set1中的值移动大另一个set2中</li></ul><h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><ul><li>hset hash field value:给hash设置字段</li><li>hget hash field:获取字段</li><li>hmset hash field1 value1 [……]:批量获取字段</li><li>hgetall hash:获取全部数据</li><li>hdel hash field：删除hash中的字段</li><li>hlen hash:获取hash字段数量</li><li>hexists hash filed：查看字段是否存在</li><li>hkeys hash:获取所有key</li><li>hvals hash:获取所有值</li><li>hincrby hash field number:field增加number</li><li>hsetnx hash field value:如果field不存在，则可以设值</li></ul><h5 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset(有序集合)"></a>zset(有序集合)</h5><ul><li>zset key1 score value:</li><li>zadd set key value:添加元素</li><li>zrange set start end:从start到end截取set元素</li><li>zrangebyscore set -inf +inf:从小到大排序</li><li>zrem set field:删除元素</li><li>zcard set：获取有序集合中的个数</li><li>zcount set start end:获取start到end之间的元素个数</li></ul><h5 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial 地理位置"></a>geospatial 地理位置</h5><p>应用：定位信息存储、附近的人计算、打车距离计算,底层维护的是一个zset，可以是有zset的操作</p><ul><li><p>geoadd key  longitude latitude member:用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</p><pre class=" language-sql"><code class="language-sql">geoadd china:city <span class="token number">116.40</span> <span class="token number">39.90</span> beijing</code></pre></li><li><p>geodist key member1 member2 [m米/km千米/ft英尺/mi英里]:按照给定的单位返回两个定位之间的距离</p><pre class=" language-sql"><code class="language-sql">geodist china:city beijing shanghai km </code></pre></li><li><p>georadius key longtitude latitude radius m/km/ft/mi:以给定的经纬度为中心，找出某一半径内的元素</p><pre class=" language-sql"><code class="language-sql">georadius china:city <span class="token number">110</span> <span class="token number">30</span> <span class="token number">1000</span> km</code></pre></li><li><p>geopos key member:获取member的经纬度</p><pre class=" language-sql"><code class="language-sql">geopos china:city beijing</code></pre></li><li><p>zrem key member：移除member</p></li><li><p>zrange key start end：截取从start到end的元素</p></li></ul><h5 id="hyperloglog"><a href="#hyperloglog" class="headerlink" title="hyperloglog"></a>hyperloglog</h5><p>用于基数统计相关，基数是指多个数据集中不重复的元素，hyperloglog存在一定的误差,但是占用的内存是固定的64k<br>网站访问人数统计等可以用次结构来做</p><ul><li>pfadd key element:添加元素</li><li>pfcount key:返回元素个数</li><li>pfmerge key1 ke2 k3:将k2和k3合并为key1</li></ul><h5 id="bitmap：位图"><a href="#bitmap：位图" class="headerlink" title="bitmap：位图"></a>bitmap：位图</h5><ul><li>setbit key offset value：把key的offset位设为value,value取值为0或1</li><li>getbit key offset:获取第offset位的值</li><li>bitcount key [start end]：获取从start到end范围内的1的个数</li></ul><h4 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h4><p>Redis的事务跟mysql登封关系型数据库是不同的，Redis单条命令是原子性的，要么成功要么失败，而Redis的事务不保证原子性。</p><p>Redis事务的本质就是一组命令的集合，将所有命令放入队列暂不执行，输入事务执行命令后才会开始执行，然后依次执行</p><p>Redis事务的顺序：</p><ol><li>开启事务</li><li>命令入队</li><li>执行事务</li></ol><pre class=" language-sql"><code class="language-sql">开启事务<span class="token operator">-</span><span class="token operator">></span>  multi   <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">set</span> k1 v1<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">set</span> k2 v2<span class="token operator">-</span><span class="token operator">></span>  get k1<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">set</span> k3 v3执行事务<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">exec</span>取消事务<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">discard</span></code></pre><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p><p>Redis的乐观锁实现采用的是watch命令</p><ul><li>watch key:监视key，如果key被改变则事务中断</li><li>unwatch key：取消监视</li></ul><p>如果事务失败，先解锁，然后重新加锁，再次进行事务操作</p><p><img src="../img/OptimisticLocking.png" alt=""></p><h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><h5 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h5><p>RDB：保存redis数据的快照，Redis会单独创建(fork)一个子进程来进行持久化,会先将数据写入到一个临时文件中，持久化进程结束后，再替换以前持久化的文件。恢复时，Redis会直接将快照读入内存。</p><p>优点:</p><ol><li>一般时候对性能影响较小</li><li>非常适合做冷备</li><li>数据恢复快</li></ol><p>缺点:</p><ol><li>如果数据量大时候，内存占用较高</li><li>可能会丢失数据</li></ol><ol><li>save触发方式：该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止<br><img src="../img/rdb.jpg" alt=""></li><li>bgsave触发方式：执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求<br><img src="../img/rdb2.jpg" alt=""></li><li>自动触发：在配置文件中设置触发规则。执行flushall或者退出Redis时，也会自动触发RDB</li></ol><h5 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h5><p>以日志的形式来记录每个写操作，将所有的指令记录下来，只许追加文件不允许写，Redis启动之后会读取该文件(appendonly.aof)重新构建。</p><p>与RDB不同，AOF需要手动开启。</p><p>AOF机制的优点:</p><ol><li>每一次修改都同步，数据完整性更高</li><li>每秒同步一次，则可能会丢失1秒的数据</li><li>从不同步，效率最高</li></ol><p>AOF的缺点：</p><ol><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</li><li>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</li><li>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> NoSQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2020/07/23/redblacktree/"/>
      <url>/2020/07/23/redblacktree/</url>
      
        <content type="html"><![CDATA[<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>定义：红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ol><li>每个节点要么是黑色，要么是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。</li><li>每个红色结点的两个子结点一定都是黑色（红黑树不会出现相邻的红色节点）</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li></ol><p>红黑树是一种黑色完美平衡的二叉树（不是完美平衡的二叉树）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 查找 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2020/07/16/tree/"/>
      <url>/2020/07/16/tree/</url>
      
        <content type="html"><![CDATA[<h4 id="树的介绍"><a href="#树的介绍" class="headerlink" title="树的介绍"></a>树的介绍</h4><p>树是节点按分支关系组成的一种结构，具有插入和删除效率高的优点，但是查找效率较低，二叉树不是树的特例（即二叉树不是树）</p><h4 id="常见二叉树分类"><a href="#常见二叉树分类" class="headerlink" title="常见二叉树分类"></a>常见二叉树分类</h4><ul><li>普通二叉树</li><li>完全二叉树</li><li>满二叉树</li><li>线索二叉树</li><li>哈夫曼树</li><li>二叉排序树</li><li>平衡二叉树（AVL）</li><li>红黑树</li></ul><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉树的存储结构可以用顺序存储和链式存储来存储。二叉树的顺序存储结构由一组连续的存储单元依次从上到下，从左到右存储完全二叉树的结点元素。对于一般二叉树，应将其与完全二叉树对应，然后给每个结点从1到i编上号，依次存储在大小为i-1的数组中。这种方法只适用于完全二叉树，对非完全二叉树会浪费较多空间，最坏情况一个深度为k的二叉树只有k个结点，却需要长度为2的k次方减一长度的一位数组。事实上，二叉树一般使用链式存储结构，由二叉树的定义可知，二叉树的结点由一个数据元素和分别指向其左右孩子的指针构成，即二叉树的链表结点中包含3个域，这种结点结构的二叉树存储结构称之为二叉链表。</p><h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/BTree.jpg" alt=""></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>定义：若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><h5 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/CompleteBinaryTree.jpg" alt=""></p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>定义：一棵二叉树的结点要么是叶子结点，要么它有两个子结点（如果一个二叉树的层数为K，且结点总数是(2^k) -1，则它就是满二叉树。）</p><h5 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/FullBinaryTree.jpg" alt=""></p><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>定义：对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树</p><h5 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/ThreadedBinaryTree.jpg" alt=""></p><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树（Huffman Tree）是在叶子结点和权重确定的情况下，带权路径长度最小的二叉树，也被称为最优二叉树。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p> <img src="../img/HuffmanTree.jpg" alt=""><br> <img src="../img/HuffmanTree2.jpg" alt=""></p><h4 id="二叉排序树（二叉搜索树、二叉查找树）"><a href="#二叉排序树（二叉搜索树、二叉查找树）" class="headerlink" title="二叉排序树（二叉搜索树、二叉查找树）"></a>二叉排序树（二叉搜索树、二叉查找树）</h4><p>定义：根节点的值大于其左子树中任意一个节点的值，小于其右节点中任意一节点的值，这一规则适用于二叉查找树中的每一个节点。</p><h5 id="图示-4"><a href="#图示-4" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/BinarySortTree.jpg" alt=""></p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>定义:可以是空树。假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过</p><h5 id="图示-5"><a href="#图示-5" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/BalanceTree.jpg" alt=""></p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>定义：红黑树就是一种平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。除了符合二叉查找树的特性之外，还具体下列的特性：</p><ol><li><p>节点是红色或者黑色</p></li><li><p>根节点是黑色</p></li><li><p>每个叶子的节点都是黑色的空节点（NULL）</p></li><li><p>每个红色节点的两个子节点都是黑色的。</p></li><li><p>从任意节点到其每个叶子的所有路径都包含相同的黑色节点。</p></li></ol><h5 id="图示-6"><a href="#图示-6" class="headerlink" title="图示"></a>图示</h5><p><img src="../img/RedBlackTree.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2020/07/15/sort/"/>
      <url>/2020/07/15/sort/</url>
      
        <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思想：将数组分为已排序和未排序两部分，每次从未排序部分选出最小的数放入已排序部分</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="../img/2059345-20200607164933854-1279339529.gif" alt=""></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>记上待排序部分的第一个数字的索引min</li><li>对待排序部分遍历，如果有比第nums[min]小的，将索引值赋min</li><li>将待排序部分首元素与nums[min]交换</li><li>重复3和4</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>cur <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> cur<span class="token operator">>=</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> min <span class="token builtin">int</span><span class="token operator">=</span>cur    <span class="token keyword">for</span> i <span class="token operator">:=</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span>  <span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">{</span>            min<span class="token operator">=</span>i        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span>    cur<span class="token operator">++</span>    <span class="token function">SelectSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>cur<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序</p><h4 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h4><p><img src="../img/7789414-fb94ab5405281f89.png" alt=""></p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li>选择一个基准值，为了方便选择待排序部分首元素,用l表示左指针，r表示右指针</li><li>遍历待排序部分，对右指针向前移动，直到有小于基准值的元素出现，将r所指的值赋予l所指的元素,l小于r</li><li>对左指针进行移动，直到有大于基准值的元素出现，l所指的值赋予r所指的元素,l小于r</li><li>当l和r相等时，就将基准值赋予该元素，基准值将数组分为左右两部分，对这两部分进行2到4的操作</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>l <span class="token builtin">int</span><span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//对左右下标进行比较，l小于r时就返回，防止程序出错</span>    <span class="token keyword">if</span> l<span class="token operator">></span>r<span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//pviot为基准值</span>    <span class="token keyword">var</span> pviot <span class="token builtin">int</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">//保存函数中传入的l原值</span>    <span class="token keyword">var</span> left <span class="token builtin">int</span><span class="token operator">=</span>l    <span class="token comment" spellcheck="true">//保存函数中传入的r原值</span>    <span class="token keyword">var</span> right <span class="token builtin">int</span><span class="token operator">=</span>r    <span class="token comment" spellcheck="true">//循环排序</span>    <span class="token keyword">for</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//基准值选了待排序部分最左边，所以从r开始</span>        <span class="token comment" spellcheck="true">//如果右边得值大于基准值，不用与左边交换，只需r减小，直到右边的值小于基准值</span>        <span class="token keyword">for</span> pviot<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">{</span>            r<span class="token operator">--</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//此时右边所指的数小于左边，需要将右边得值赋给左边</span>        <span class="token keyword">if</span> r<span class="token operator">></span>l<span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> pviot<span class="token operator">>=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">{</span>            l<span class="token operator">++</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> r<span class="token operator">></span>l<span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//此时l和r指向同一个数字，把基准值放在此处</span>    nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>pviot    <span class="token comment" spellcheck="true">//对基准值左边进行快速排序</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>l<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//对基准值右边进行快速排序</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想：归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法的一个非常典型的应用，且各层分治递归可以同时进行。</p><ul><li>分解（Divide）： 将n个元素分成个含n/2个元素的子序列。</li><li>解决（Conquer）：用合并排序法对两个子序列递归的排序。</li><li>合并（Combine）：合并两个已排序的子序列已得到排序结果。</li></ul><h4 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h4><p><img src="../img/7789414-b410a7c0fea50eba.png" alt=""></p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li>对待排序部分分为左右两部分</li><li>对左边部分递归进行归并排序</li><li>对右边部分递归进行归并排序</li><li>对这两部分进行合并</li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>l <span class="token builtin">int</span><span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> l<span class="token operator">>=</span>r<span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> middle <span class="token builtin">int</span><span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>    <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>middle<span class="token punctuation">)</span>    <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span>    <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>middle<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">merge</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>l <span class="token builtin">int</span><span class="token punctuation">,</span>r <span class="token builtin">int</span><span class="token punctuation">,</span>middle <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> temp <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span><span class="token operator">=</span><span class="token number">0</span>    <span class="token keyword">var</span> j <span class="token builtin">int</span><span class="token operator">=</span>l    <span class="token keyword">var</span> k <span class="token builtin">int</span><span class="token operator">=</span>middle<span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">for</span> j<span class="token operator">&lt;=</span>middle<span class="token operator">&amp;&amp;</span>k<span class="token operator">&lt;=</span>r<span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j<span class="token operator">++</span>            i<span class="token operator">++</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>            k<span class="token operator">++</span>            i<span class="token operator">++</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> j<span class="token operator">&lt;=</span>middle<span class="token punctuation">{</span>        temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        j<span class="token operator">++</span>        i<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> k<span class="token operator">&lt;=</span>r<span class="token punctuation">{</span>        temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        k<span class="token operator">++</span>        i<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>l<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>思想：工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序，有可能再使用别的排序算法或是以递归方式继续使用桶排序</p><h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里面去；</li><li>对每个不是空的桶进行排序。</li><li>从不是空的桶里面把排序好的数据进行拼接；</li></ul><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>思想：它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h5 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h5><ol><li>将第一个元素视为已经排序</li><li>从第一个元素开始依次向后取出元素，与它前面已经排序的序列比较，将它插入到合适的位置</li></ol><h5 id="图解-3"><a href="#图解-3" class="headerlink" title="图解"></a>图解</h5><p><img src="../img/insertSort.jpg" alt=""></p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>cur <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> cur<span class="token operator">>=</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> temp <span class="token builtin">int</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span>    <span class="token keyword">for</span> i<span class="token operator">=</span>cur<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span>temp <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp            <span class="token keyword">break</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">InsertSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="希尔排序（shell-sort）"><a href="#希尔排序（shell-sort）" class="headerlink" title="希尔排序（shell sort）"></a>希尔排序（shell sort）</h4><p>思想:希尔排序算是对简单插入排序的一种改进，属于一种增量式的排序算法，通过对数组”分组微调”,使大部分元素有序，减少插入排序的工作量</p><h5 id="图解-4"><a href="#图解-4" class="headerlink" title="图解"></a>图解</h5><p><img src="../img/shellsort.png" alt=""></p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> n <span class="token builtin">int</span><span class="token operator">=</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>    <span class="token keyword">for</span> n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span>n<span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>            <span class="token keyword">var</span> temp <span class="token builtin">int</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">var</span> tag <span class="token builtin">int</span><span class="token operator">=</span>i<span class="token operator">-</span>n            <span class="token keyword">for</span> tag<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token operator">></span>temp<span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>tag<span class="token operator">+</span>n<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>tag<span class="token punctuation">]</span>                tag<span class="token operator">=</span>tag<span class="token operator">-</span>n            <span class="token punctuation">}</span>            nums<span class="token punctuation">[</span>tag<span class="token operator">+</span>n<span class="token punctuation">]</span><span class="token operator">=</span>temp        <span class="token punctuation">}</span>        n<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/04/hello-world/"/>
      <url>/2020/07/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
